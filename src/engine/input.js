/**
 * input.js
 * Keyboard + Gamepad input with buffered state for edge detection (pressed/held/released).
 * Gamepad mapping generated by tools/map-controller.py.
 */

const DEFAULT_BINDINGS = {
    left:  ['ArrowLeft', 'KeyA'],
    right: ['ArrowRight', 'KeyD'],
    up:    ['ArrowUp', 'KeyW'],
    down:  ['ArrowDown', 'KeyS'],
    jump:  ['KeyZ', 'Space'],
    shoot: ['KeyX'],
    dash:  ['KeyC', 'ShiftLeft'],
    start: ['Enter'],
    select: ['Backspace'],
};

// Gamepad mapping from tools/controller-map.json
// 8BitDo Ultimate 2C Wireless Controller
const GAMEPAD_MAP = {
    shoot: 3,   // X button (browser index differs from SDL)
    jump:  0,   // A button
    dash:  1,   // B button
};

// Browser Gamepad API standard d-pad button indices
const DPAD_UP    = 12;
const DPAD_DOWN  = 13;
const DPAD_LEFT  = 14;
const DPAD_RIGHT = 15;

// Analog stick config
const ANALOG_X     = 0;
const ANALOG_Y     = 1;
const ANALOG_DEAD  = 0.3;  // deadzone â€” ignore stick drift below this

export class Input {
    constructor(bindings = DEFAULT_BINDINGS) {
        this.bindings = bindings;
        this.rawKeys = {};
        this.current = {};
        this.prev = {};

        // Gamepad state (merged with keyboard each frame)
        this.padButtons = {};
        this.padConnected = false;

        window.addEventListener('keydown', (e) => {
            this.rawKeys[e.code] = true;
            if (this._isGameKey(e.code)) e.preventDefault();
        });

        window.addEventListener('keyup', (e) => {
            this.rawKeys[e.code] = false;
        });

        // Listen for gamepad connect/disconnect
        window.addEventListener('gamepadconnected', (e) => {
            console.log(`Gamepad connected: ${e.gamepad.id}`);
            this.padConnected = true;
        });
        window.addEventListener('gamepaddisconnected', (e) => {
            console.log(`Gamepad disconnected: ${e.gamepad.id}`);
            this.padConnected = false;
        });

        // Initialize state
        for (const action of Object.keys(this.bindings)) {
            this.current[action] = false;
            this.prev[action] = false;
        }
    }

    _isGameKey(code) {
        for (const codes of Object.values(this.bindings)) {
            if (codes.includes(code)) return true;
        }
        return false;
    }

    /** Read raw gamepad state from the browser Gamepad API. */
    _pollGamepad() {
        // Reset pad state
        this.padButtons = {};

        const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
        let gp = null;
        for (const pad of gamepads) {
            if (pad && pad.connected) { gp = pad; break; }
        }
        if (!gp) return;

        const btns = gp.buttons;
        const axes = gp.axes;



        // Action buttons
        if (btns[GAMEPAD_MAP.shoot]?.pressed) this.padButtons.shoot = true;
        if (btns[GAMEPAD_MAP.jump]?.pressed)  this.padButtons.jump = true;
        if (btns[GAMEPAD_MAP.dash]?.pressed)  this.padButtons.dash = true;

        // Start / Select (standard mapping)
        if (btns[9]?.pressed) this.padButtons.start = true;
        if (btns[8]?.pressed) this.padButtons.select = true;

        // D-pad buttons (standard mapping: 12=up, 13=down, 14=left, 15=right)
        if (btns[DPAD_UP]?.pressed)    this.padButtons.up = true;
        if (btns[DPAD_DOWN]?.pressed)  this.padButtons.down = true;
        if (btns[DPAD_LEFT]?.pressed)  this.padButtons.left = true;
        if (btns[DPAD_RIGHT]?.pressed) this.padButtons.right = true;

        // Analog stick (also maps to directional actions)
        if (axes.length > ANALOG_Y) {
            const ax = axes[ANALOG_X];
            const ay = axes[ANALOG_Y];

            if (ax < -ANALOG_DEAD) this.padButtons.left = true;
            if (ax >  ANALOG_DEAD) this.padButtons.right = true;
            if (ay < -ANALOG_DEAD) this.padButtons.up = true;
            if (ay >  ANALOG_DEAD) this.padButtons.down = true;
        }
    }

    /** Call once per frame before update logic. */
    poll() {
        this._pollGamepad();

        for (const action of Object.keys(this.bindings)) {
            this.prev[action] = this.current[action];
            // Merge: keyboard OR gamepad triggers the action
            const kbActive = this.bindings[action].some(c => this.rawKeys[c]);
            const padActive = !!this.padButtons[action];
            this.current[action] = kbActive || padActive;
        }
    }

    /** True while the action button is held down. */
    held(action) {
        return this.current[action];
    }

    /** True only on the frame the button was first pressed. */
    pressed(action) {
        return this.current[action] && !this.prev[action];
    }

    /** True only on the frame the button was released. */
    released(action) {
        return !this.current[action] && this.prev[action];
    }
}
