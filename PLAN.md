# MEGAGAME 2026: SNES to JavaScript Port Plan

## Context

We're porting **MEGAGAME 2026**, a 1.5MB LoROM SNES action platformer (Mega Man X2), to a native JavaScript game using plain HTML5 Canvas. The ROM is at `mega-game-raw.sfc` (binary). The ROM contains story references to Mega Man X characters (Sigma, Zero, X-Hunters, Dr. Cain).

**Goal:** A playable browser game — not an emulator wrapper.

---

## Plan 1.0 — ROM-Based Sprite Extraction (ABANDONED)

### Summary

Our original approach was to extract all sprite graphics directly from the SNES ROM data, decoding tiles, palettes, and animation frames from raw ROM bytes. This involved:

1. **ROM Parsing Pipeline** — Built hex parser, LoROM mapper, 4bpp tile decoder, and SNES palette decoder. All working correctly — tiles and palettes decode fine.

2. **CX4 Coprocessor Reverse Engineering** — Disassembled the CX4 DMA sprite routine at `$08:CA5C`, decoded the DMA transfer table at `$05:$9609` (112 entries, 6-byte format), and mapped out the full animation system (11 animations, 19 sprite defs, 3-byte frame entries at `$2F:D4D6`).

3. **OAM Layout Discovery** — Decoded the CX4 sub-sprite system at `$0D:$B01E` (variable-count defs per frame, up to 31 sub-sprites), and confirmed a 4-block OAM layout: head, upper-body-left, upper-body-right, and legs.

4. **DMA Tile Remapping** — Each of the 19 sprite defs remaps VRAM tiles 0-31 to different positions in the ROM tilesheet at `0x168000`. Wrote `sprite-frames.js` with per-def tile remap tables.

### Why It Failed

**The CX4 coprocessor made this approach impractical.** The Capcom CX4 (Hitachi HG51B169 DSP) is a custom coprocessor that handles player sprite assembly at runtime. Key problems:

- **Runtime code injection**: The CX4 uploads wrapper routines to WRAM at `$7E:2680-$7E:2692` during initialization. These routines are NOT in the cartridge ROM — they're generated by the CX4 chip itself. Without emulating the CX4, we cannot reproduce these routines.

- **Complex multi-layer sprite assembly**: The CX4's Build OAM function (`op00_00`) assembles up to 31 sub-sprites per frame, including 8-9 body blocks plus 22-23 detail/effect overlays (8x8 sprites for outline details, helmet gem, buster glow, etc.). Our simplified 4-block layout captured the basic shape but missed all the detail sprites that make the character look correct.

- **Missing leg tile source**: Leg tiles (VRAM positions 64, 65, 80, 81) are loaded by a separate init mechanism not part of the main DMA table. Tiles 64-65 were found at ROM `$2F:$8D40`, but tiles 80-81 appear to be CX4-generated at runtime. We had to resort to savestate extraction as a fallback.

- **Palette runtime modification**: ROM palette 14 is correct structurally, but the game modifies palettes at runtime for charge effects, damage flashing, etc. The savestate showed palette 14 as all-zeros at the expected CGRAM position.

- **Net result**: After weeks of reverse engineering, the rendered sprites were recognizable but visually broken — wrong colors, missing detail tiles, garbled leg tiles. The CX4 does too much runtime processing to replicate from static ROM analysis alone.

### What Was Preserved

The ROM parsing pipeline (Phase 1) still works and is used for background tiles:
- `src/rom/hex-parser.js` — ROM binary loading
- `src/rom/lorom.js` — SNES address mapping
- `src/rom/tile-decoder.js` — 4bpp tile decoding
- `src/rom/palette-decoder.js` — SNES palette decoding
- Background terrain tiles render correctly from ROM data (tileset at `0x158000`, palette at `0x2BE00`)

All reverse engineering findings are preserved below in the **Appendix** for reference.

---

## Plan 2.0 — MMX Deathmatch Sprite Source (CURRENT)

### New Approach

We discovered [MMX-Online-Deathmatch](https://github.com/gamemaker19/MMX-Online-Deathmatch), an open-source Mega Man X fan game with complete, high-quality sprite assets. The project contains:

- **Pre-made PNG spritesheets** with all character animations laid out cleanly
- **JSON animation definitions** with precise frame rects, durations, offsets, and POI (point of interest) data for projectile spawn positions
- **Multiple character spritesheets** (X, Zero, Vile, Sigma, Axl, 26+ Mavericks)
- **Effects spritesheets** for projectiles, explosions, and other VFX

All needed assets are copied into our `assets/` folder — nothing references the `MMX-Online-Deathmatch/` directory at runtime.

### Current Status

**Working:**
- Player spritesheet (`assets/XDefault.png`) loaded and rendering correctly
- 18 animations in `src/entities/sprite-data.js` (auto-generated from MMX Deathmatch JSONs)
- States confirmed working in-game: idle, run, jump, fall, wall_slide, dash, hurt
- Wall slide flip fix applied (sprite inverted for correct wall-facing)
- Background tiles still render from ROM data
- Full movement state machine (run, jump, wall-jump, dash, shoot mechanics)

### Plan Items

---

### 1. Finish Player Sprites

The basic movement animations are working. What's missing is the **shooting animation overlay system**.

#### What exists in sprite-data.js (already generated):
| Animation | Frames | Loop | Description |
|-----------|--------|------|-------------|
| `shoot` | 2 | no | Shooting while idle/stationary |
| `run_shoot` | 10 | yes | Shooting while running |
| `jump_shoot` | 3 | no | Shooting while jumping/rising |
| `fall_shoot` | 2 | no | Shooting while falling |
| `dash_shoot` | 2 | no | Shooting while dashing |
| `wall_slide_shoot` | 1 | no | Shooting while wall sliding |

#### What needs to be implemented in player.js:

**Shoot animation overlay system** (based on MMX Deathmatch logic):

1. **`shootAnimTimer`** — When the player fires, set a timer (0.3 seconds = 18 frames at 60fps). While this timer is active, use the `_shoot` variant of the current state's animation instead of the normal one.

2. **State-to-shoot-animation mapping:**
   ```
   idle       → shoot
   run        → run_shoot
   jump       → jump_shoot
   fall       → fall_shoot
   dash       → dash_shoot
   wall_slide → wall_slide_shoot
   ```

3. **Shoot animation carries across state transitions** — If the player fires while idle then starts running, the shoot timer persists and `run_shoot` is used instead of `run`. The timer counts down regardless of state changes.

4. **Projectile spawn position** — Each frame in sprite-data.js has `hx` and `hy` values (hand/buster position relative to sprite anchor). Projectiles should spawn at these coordinates, adjusted for facing direction.

#### Other player animations to wire up later:
- `land` — Brief landing squash animation (2 frames)
- `warp_in` — Level start teleport beam (6 frames)
- `die` — Death animation (2 frames)
- `crouch` — Crouching (1 frame, if we add crouch mechanic)

---

### 2. Other Character Sprites

The MMX Deathmatch project contains spritesheets for many characters. Available at `MMX-Online-Deathmatch/LevelEditor/assets/spritesheets/`:

#### Priority characters:
| Character | Spritesheet | JSON Folder | Notes |
|-----------|-------------|-------------|-------|
| **Zero** | `ZeroDefault.png` | `sprites/zero/` | Second protagonist, sword-based |
| **Vile** | `VileDefault.png` | `sprites/vile/` | Enemy/boss character |
| **Sigma** | `SigmaDefault.png` | `sprites/sigma/` | Final boss |

#### Additional characters (lower priority):
- `AxlDefault.png` — Axl (X7/X8 character)
- 26+ Maverick boss spritesheets (`CrushCrawfish.png`, `StormEagle.png`, etc.)
- Each has corresponding JSON animation definitions

#### Implementation plan:
1. Copy needed spritesheets to `assets/`
2. Run `build_sprite_module.py` (or a variant) to generate sprite-data modules for each character
3. Create entity classes extending `Entity` with character-specific state machines
4. Enemies can use simpler AI state machines (patrol, chase, attack patterns)

---

### 3. Shooting & Projectile System

#### Current state:
- Player can shoot (basic projectile rectangles, cyan colored)
- Max 3 shots on screen, 8-frame cooldown
- Projectiles collide with walls and despawn off-screen
- Projectile spawn position uses hitbox center (not hand POI)

#### What needs to change:

**a) Visual projectile sprites** from `assets/effects.png`:
- Normal buster shot: `effects.png` rect (123, 253) to (131, 259) — 8×6 pixels
- Buster fade/hit: `effects.png` from `buster1_fade.json` frames
- Need to extract frame rects from effects JSON files

**b) Projectile spawn from hand POI:**
- Use `hx`, `hy` from current animation frame in sprite-data.js
- Adjust for facing direction (flip hx when facing left)
- Currently spawns from hitbox edge — should spawn from hand position

**c) Charged shot (future):**
- MMX Deathmatch has charge levels 1-4 with different projectile sizes/damage
- Charge animations: `shoot_charge1`, `shoot_charge2`, etc.
- Visual charge glow effect on character while charging
- This is a stretch goal — normal buster first

**d) Projectile rendering:**
- Replace solid cyan rectangles with actual sprite frames from effects.png
- Add projectile hit/fade animation when hitting walls or enemies
- Different projectile types could use different effect sprites

---

### Implementation Priority

1. **Shooting overlay animations** — Wire `shootAnimTimer` into player.js, use `_shoot` animation variants
2. **Projectile spawn from POI** — Use `hx`/`hy` from sprite frame data
3. **Projectile sprites** — Load effects.png, render actual buster shot sprites
4. **Enemy characters** — Start with one Maverick as a test enemy
5. **Boss fights** — Multi-phase boss AI
6. **Charged shot** — Hold-to-charge buster mechanic

---

## Project Structure (Current)

```
mega-port/
├── index.html                    — Main game page (256×224 canvas, 3× scale)
├── mega-game-raw.sfc             — Source ROM binary (1.5MB)
├── PLAN.md                       — This file
├── assets/
│   ├── XDefault.png              — Player spritesheet (from MMX Deathmatch)
│   └── effects.png               — Projectile/VFX spritesheet (from MMX Deathmatch)
├── src/
│   ├── rom/                      — ROM parsing (hex-parser, lorom, tile-decoder, palette-decoder)
│   ├── engine/                   — Game loop, rendering, input, camera, collision
│   │   ├── game.js               — Fixed 60fps game loop
│   │   ├── input.js              — Keyboard input (pressed/held/released)
│   │   ├── renderer.js           — SpriteSheet class (tile→canvas rendering)
│   │   ├── camera.js             — Viewport scrolling (256×224)
│   │   └── collision.js          — Tile-based AABB collision
│   ├── entities/
│   │   ├── entity.js             — Base entity class
│   │   ├── player.js             — Player state machine + rendering
│   │   └── sprite-data.js        — Player animation frame data (auto-generated)
│   ├── states/
│   │   └── gameplay.js           — Main gameplay state (level, player, camera, HUD)
│   ├── levels/
│   │   └── level.js              — Test level (collision grid + visual tiles)
│   └── assets/
│       └── asset-loader.js       — ROM + image loading/caching
├── analysis/
│   ├── build_sprite_module.py    — Generates sprite-data.js from MMX Deathmatch JSONs
│   ├── disasm65816.py            — 65816 disassembler
│   ├── decode_player_anims.py    — ROM animation decoder
│   ├── generate_metasprite_data.py — CX4 sub-sprite reader
│   ├── generate_sprite_data.py   — Old ROM-based sprite-frames.js generator
│   └── find_legs.py              — DMA remap analysis
├── tools/
│   ├── tile-viewer.html          — ROM tile browser
│   ├── sprite-assembler.html     — Manual sprite assembly tool
│   └── sprite-finder.html        — Tile search tool
└── MMX-Online-Deathmatch/        — Reference project (NOT used at runtime)
```

---

## Appendix: ROM Reverse Engineering Findings

_Preserved from Plan 1.0 for reference. This data is accurate but the tile-based rendering approach was abandoned in favor of PNG spritesheets._

### Hardware: CX4 Coprocessor

The cartridge PCB is **SHVC-2DC0N-01** with a **Capcom CX4** coprocessor (Hitachi HG51B169 DSP, 20 MHz). ROM header chipset byte = `$F3` (CX4 confirmed). The CX4 is mapped at `$6000-$7FFF` in banks `$00-$3F`.

The CX4 handles:
- Player sprite DMA (tile streaming from ROM to VRAM)
- OAM table construction (assembling sprite objects from parts)
- Wireframe 3D effects (intro sequences)
- Trigonometric calculations for scaling/rotation

### Key ROM Addresses

| Address | ROM Offset | Purpose |
|---------|-----------|---------|
| `$00:80BE` | `0x0000BE` | CX4 initialization |
| `$00:A8A6` | `0x00A8A6` | Player spawn: entity type `$9D` |
| `$08:85DD` | `0x0405DD` | Entity sprite handler pointer table |
| `$08:C690` | `0x044690` | Animation controller init |
| `$08:C673` | `0x044673` | Animation tick |
| `$08:CA5C` | `0x044A5C` | CX4 sprite DMA routine |
| `$2F:D4D6` | `0x17D4D6` | Player animation base (11 anims, defs 0-18) |
| `$05:9609` | `0x029609` | Player sprite DMA transfer table (112 entries) |

### Animation System

3-byte frame format: `[duration] [flags] [sprite_def_index]`
- 11 animations, 19 sprite defs
- DMA remaps tiles 0-31 per frame, legs (64+) loaded at init
- Palette 14 at ROM `0x02BFC0`

### DMA Transfer Entry Format (6 bytes)

```
[0] Tile count (×16 = byte count)
[1] Source addr low
[2] Source addr high
[3] Source bank ($2D = player tilesheet at 0x168000)
[4] VRAM dest low
[5] VRAM dest high (bit 15 = last entry flag)
```

### 4-Block OAM Layout

```
head:   VRAM tiles (0,1,16,17)  at pixel (16, 2)
ubodyL: VRAM tiles (4,5,20,21)  at pixel (12, 16)
ubodyR: VRAM tiles (6,7,22,23)  at pixel (20, 16)
legs:   VRAM tiles (64,65,80,81) at pixel (16, 32)
```
