# MEGAGAME 2026: Mega Man X Browser Game

## Context

A Mega Man X-style action platformer built with plain HTML5 Canvas and JavaScript. All sprite and stage assets sourced from [MMX-Online-Deathmatch](https://github.com/gamemaker19/MMX-Online-Deathmatch), an open-source fan game with complete, high-quality PNG spritesheets and JSON animation data. Originally started as a SNES ROM port (Plan 1.0, abandoned due to CX4 coprocessor complexity).

**Goal:** A playable browser game with authentic MMX gameplay — not an emulator wrapper.

---

## Plan 1.0 — ROM-Based Sprite Extraction (ABANDONED)

### Summary

Our original approach was to extract all sprite graphics directly from the SNES ROM data, decoding tiles, palettes, and animation frames from raw ROM bytes. This involved:

1. **ROM Parsing Pipeline** — Built hex parser, LoROM mapper, 4bpp tile decoder, and SNES palette decoder. All working correctly — tiles and palettes decode fine.

2. **CX4 Coprocessor Reverse Engineering** — Disassembled the CX4 DMA sprite routine at `$08:CA5C`, decoded the DMA transfer table at `$05:$9609` (112 entries, 6-byte format), and mapped out the full animation system (11 animations, 19 sprite defs, 3-byte frame entries at `$2F:D4D6`).

3. **OAM Layout Discovery** — Decoded the CX4 sub-sprite system at `$0D:$B01E` (variable-count defs per frame, up to 31 sub-sprites), and confirmed a 4-block OAM layout: head, upper-body-left, upper-body-right, and legs.

4. **DMA Tile Remapping** — Each of the 19 sprite defs remaps VRAM tiles 0-31 to different positions in the ROM tilesheet at `0x168000`. Wrote `sprite-frames.js` with per-def tile remap tables.

### Why It Failed

**The CX4 coprocessor made this approach impractical.** The Capcom CX4 (Hitachi HG51B169 DSP) is a custom coprocessor that handles player sprite assembly at runtime. Key problems:

- **Runtime code injection**: The CX4 uploads wrapper routines to WRAM at `$7E:2680-$7E:2692` during initialization. These routines are NOT in the cartridge ROM — they're generated by the CX4 chip itself. Without emulating the CX4, we cannot reproduce these routines.

- **Complex multi-layer sprite assembly**: The CX4's Build OAM function (`op00_00`) assembles up to 31 sub-sprites per frame, including 8-9 body blocks plus 22-23 detail/effect overlays (8x8 sprites for outline details, helmet gem, buster glow, etc.). Our simplified 4-block layout captured the basic shape but missed all the detail sprites that make the character look correct.

- **Missing leg tile source**: Leg tiles (VRAM positions 64, 65, 80, 81) are loaded by a separate init mechanism not part of the main DMA table. Tiles 64-65 were found at ROM `$2F:$8D40`, but tiles 80-81 appear to be CX4-generated at runtime. We had to resort to savestate extraction as a fallback.

- **Palette runtime modification**: ROM palette 14 is correct structurally, but the game modifies palettes at runtime for charge effects, damage flashing, etc. The savestate showed palette 14 as all-zeros at the expected CGRAM position.

- **Net result**: After weeks of reverse engineering, the rendered sprites were recognizable but visually broken — wrong colors, missing detail tiles, garbled leg tiles. The CX4 does too much runtime processing to replicate from static ROM analysis alone.

### What Was Preserved

The ROM parsing pipeline was fully removed in Plan 2.1. All `src/rom/` files, `sprite-frames.js`, and `asset-map.json` have been deleted. Background rendering now uses pre-rendered PNG images from MMX-Online-Deathmatch stage assets.

All reverse engineering findings are preserved below in the **Appendix** for reference.

---

## Plan 2.0 — MMX Deathmatch Sprite Source (CURRENT)

### New Approach

We discovered [MMX-Online-Deathmatch](https://github.com/gamemaker19/MMX-Online-Deathmatch), an open-source Mega Man X fan game with complete, high-quality sprite assets. The project contains:

- **Pre-made PNG spritesheets** with all character animations laid out cleanly
- **JSON animation definitions** with precise frame rects, durations, offsets, and POI (point of interest) data for projectile spawn positions
- **Multiple character spritesheets** (X, Zero, Vile, Sigma, Axl, 26+ Mavericks)
- **Effects spritesheets** for projectiles, explosions, and other VFX

All needed assets are copied into our `assets/` folder — nothing references the `MMX-Online-Deathmatch/` directory at runtime.

### Current Status

**Player Character (X):**
- Spritesheet: `assets/XDefault.png`, 19 animations in `sprite-data.js`
- 10-state machine: warp_in, idle, run, jump, fall, land, wall_slide, dash, hurt, die
- Warp-in animation on spawn (input locked), land squash on landing (jump-cancellable)
- Dash snaps directly to idle/run on ground (no transition anim, matches original MMX)
- 6 shoot animation overlays (idle, run, jump, fall, dash, wall_slide)
- Buster projectile from `assets/effects.png` (8x6 shot, 3-frame fade on wall hit)
- Projectile spawn from hand POI (`hx`/`hy` per animation frame)
- Wall slide: sprite flipped for wall-facing, shoots away from wall
- Dash-jump momentum: `isDashing` flag preserves 2x speed through jump/fall, clears on landing
- Charged buster: hold shoot to charge (2 levels), release for bigger animated projectile
- 8 charge particles orbit player while charging, character flashes white

**Enemies:**
- Tank Mechaniloid: patrol/turn/chase/attack/dying AI, 8 HP, fires projectiles
- Sprites from `assets/sigma_viral.png`, death explosion from `assets/effects.png`
- Full collision system: player shots hit enemies, enemy shots/body hit player

**Stage:**
- Highway stage from MMX-Deathmatch PNG assets (parallax + backwall + background layers)
- Collision rasterized from map.json polygon data onto 16x16 tile grid
- Spawn points loaded from map.json instances

**Engine:**
- Fixed 60fps game loop, keyboard input with pressed/held/released edge detection
- Tile-based AABB collision, camera viewport scrolling (256x224)
- Asset loader for images + JSON, no ROM dependency

### Plan Items

---

### 1. Finish Player Sprites (DONE)

**Completed:**
- ~~`land`~~ — Landing squash animation wired into state machine (jump-cancellable)
- ~~`warp_in`~~ — Level start teleport beam plays on spawn
- ~~`die`~~ — Death animation on 0 HP
- `crouch` — Crouching (1 frame, data exists, not wired — future if we add crouch mechanic)

**Note:** `dash_end` was initially added but removed after research showed original MMX has no dash-end transition — X snaps directly to idle/run.

---

### 2. Other Character Sprites

The MMX Deathmatch project contains spritesheets for many characters. Available at `MMX-Online-Deathmatch/LevelEditor/assets/spritesheets/`:

#### Priority characters:
| Character | Spritesheet | JSON Folder | Notes |
|-----------|-------------|-------------|-------|
| **Zero** | `ZeroDefault.png` | `sprites/zero/` | Second protagonist, sword-based |
| **Vile** | `VileDefault.png` | `sprites/vile/` | Enemy/boss character |
| **Sigma** | `SigmaDefault.png` | `sprites/sigma/` | Final boss |

#### Additional characters (lower priority):
- `AxlDefault.png` — Axl (X7/X8 character)
- 26+ Maverick boss spritesheets (`CrushCrawfish.png`, `StormEagle.png`, etc.)
- Each has corresponding JSON animation definitions

#### Implementation plan:
1. Copy needed spritesheets to `assets/`
2. Run `build_sprite_module.py` (or a variant) to generate sprite-data modules for each character
3. Create entity classes extending `Entity` with character-specific state machines
4. Enemies can use simpler AI state machines (patrol, chase, attack patterns)

---

### 3. Shooting & Projectile System (DONE)

All shooting features are implemented:
- Buster shot sprites from `effects.png` (8x6 sprite, direction-aware rendering)
- 3-frame fade/hit animation on wall collision
- Hand POI-based spawn position (`hx`/`hy` per animation frame)
- Max 3 shots, 8-frame cooldown
- 6 shoot animation overlays (idle, run, jump, fall, dash, wall_slide)

---

### 4. Dash-Jump Momentum (DONE)

- `isDashing` boolean flag preserves dash speed (2x multiplier) through jump/fall states
- Set on dash entry, persists through jump-cancel and air states
- Cleared on landing (land state), wall slide, hurt, or dash expiring on ground
- Matches MMX-Online-Deathmatch behavior: speed recomputed per frame (not inertia), releasing direction = stop

---

### 5. Charged Buster Shot (DONE)

Hold shoot to charge, release for bigger projectile:
- **Charge Level 1** (0.75s / 45 frames): buster2 projectile, damage 2, speed 6.0
- **Charge Level 2** (1.75s / 105 frames): buster3 projectile, damage 3, speed 7.0
- Normal lemon fires on press, charge builds while holding, charged shot fires on release
- 8 charge particles orbit player at 24px radius, converging toward center
- Character flashes white while charging (lighter composite at 40% alpha)
- Animated projectile sprites with startup → loop → fade phases
- Charge cleared on hurt/die

Sprite sources (all from effects.png):
- buster2: 8 frames (5 startup, 3 loop), buster3: 5 frames (2 startup, 3 loop)
- charge_part_1 (level 1): 2x2 → 1x1 pixels, charge_part_2 (level 2): 4x4 → 1x1 pixels

---

### 6. Enemy Characters (DONE — Tank Mechaniloid)

First enemy implemented: **Tank Mechaniloid** from `sigma_viral.png`.

**AI State Machine (5 states):**
- `patrol` — Walk left/right within 150px of spawn, turn at ledges/walls
- `turn` — Play 1-frame turn animation (10 frames), then flip direction
- `chase` — Move toward player when spotted within 130px sight range
- `attack` — Stop and fire projectile when player is within 125px horizontal, 30px vertical
- `dying` — Play 8-frame explosion animation from effects.png, then remove

**Combat:**
- 8 HP, takes damage from player buster shots (normal and charged)
- Fires 8x7 pixel projectile (damage 2, speed 3.0, 30-frame lifetime)
- Contact damage: 3 damage on body touch (60-frame cooldown)
- Projectile spawn from POI offset (20px forward, 15px up from feet)

**Collision System (in gameplay.js):**
- Player shots vs enemies: AABB overlap check, shot destroyed on hit
- Charged shots use larger hitboxes (20x16 for level 1, 32x28 for level 2)
- Enemy shots vs player: triggers `player.takeDamage()` with knockback direction
- Enemy body vs player: contact damage with cooldown

**Sprites:** 4 animations (walk: 2 frames, turn: 1 frame, shoot: 2 frames, proj: 1 frame), all from `sigma_viral.png` row y=991-1023. Death explosion: 8 frames from `effects.png`.

---

### 9. More Enemy Types (DONE — Hopper + Bird)

#### Hopper Mechaniloid (`hopper-enemy.js`)

**AI State Machine (4 states):**
- `idle` — Waits on ground, faces player, timer before next hop
- `hop` — Jumps toward player (3-frame hop animation), lands → idle or attack
- `attack` — Melee slash when in close range (4-frame looping animation with forward hitbox)
- `dying` — 8-frame explosion from effects.png, then remove

**Combat:**
- 6 HP, takes damage from player buster shots
- Melee attack: 4 damage, 32x15 forward hitbox extending from body
- Contact damage: 3 damage on body touch (60-frame cooldown)
- Hops toward player at 1.2 px/frame, jump velocity -3.5

**Sprites:** 3 animations (idle: 1 frame, hop: 3 frames, attack: 4 frames), all from `sigma_viral.png` y=991-1021. Alignment: botmid.

#### Bird Mechaniloid (`bird-enemy.js`)

**AI State Machine (3 states):**
- `fly` — Patrols horizontally with sine-wave vertical oscillation (20px amplitude)
- `swoop` — Dives toward player position at 2.5 px/frame, then returns to patrol height
- `dying` — 8-frame explosion from effects.png, then remove

**Combat:**
- 4 HP, takes damage from player buster shots
- Contact damage: 3 damage on body touch (60-frame cooldown)
- No projectile attack — relies on swooping and body contact

**Sprites:** 1 animation (fly: 3 frames looping wing-flap), from `sigma_viral.png` y=999-1023. Alignment: center (not botmid — flying enemy doesn't anchor to ground). No tile collision.

---

### 10. Classic MMX HP Bar (DONE)

Replaced the simple rectangle health bar with the authentic MMX vertical segmented bar using sprites from `effects.png`.

**Sprite assets (all from effects.png, alignment: botmid):**

| Sprite | Source Rect (x,y → w×h) | Purpose |
|--------|------------------------|---------|
| Health base (X) | (2,55) → 14×16 | Bottom piece with character icon |
| Health full | (2,51) → 14×2 | Filled cell (one per HP point) |
| Health empty | (2,37) → 14×2 | Empty cell |
| Health top cap | (34,13) → 14×4 | Top piece capping the bar |

**Two layouts (toggle with L key):**
- **Vertical** (default) — Classic MMX style, upper-left corner, base at bottom, cells stacked upward
- **Horizontal** — Same sprites rotated 90° CW, upper-left corner, base on left, cells extending right

**Screen position:** Upper-left corner (x=8, y=8 padding).

---

### 11. Enemy Damage Flash + Shot Hit Effect (DONE)

**Enemy damage flash (white flash on hit):**
- All enemy types (Tank, Hopper, Bird) flash near-white for 6 frames (~0.1s) when hit
- Technique: `globalCompositeOperation = 'lighter'` at 0.7 alpha (same as charge flash, stronger)
- `hitFlashTimer` set to 6 in `onHit()`, decremented each frame

**Shot hit effect (buster fade on enemy hit):**
- Buster shots now play the 3-frame fade animation when hitting enemies (same as wall hits)
- Changed `shot.active = false` to `shot.fading = true` in `_checkPlayerShotsVsEnemies()`

---

### 12. Gamepad Support (DONE)

**Controller mapping tool** (`tools/map-controller.py`):
- Python/pygame script walks through each action (shoot, jump, dash, d-pad, analog stick)
- Captures axis baselines to handle controllers with non-zero trigger resting values (8BitDo triggers rest at -1.0)
- Outputs `tools/controller-map.json`

**Browser Gamepad API integration** (`src/engine/input.js`):
- Polls `navigator.getGamepads()` each frame, merges with keyboard input
- D-pad (buttons 12-15) and analog stick (axes 0/1 with 0.3 deadzone) both map to directional actions
- Note: browser button indices may differ from SDL/pygame (e.g. 8BitDo X button = SDL 2, browser 3)

---

### 13. Import Second Stage Map (DONE — Chill Penguin / Frozen Town)

Imported the Chill Penguin stage ("frozentown") from MMX-Online-Deathmatch.

**Stage details:**
- Internal name: `frozentown` (displayName: "frozen town")
- Dimensions: 1792 × 767 px (multi-tier vertical layout, much taller than highway's 224px)
- Kill zone at y=583 (death pit in the middle section)
- Parallax background with 0.5x scroll on both X and Y axes
- Purple night sky with snow-covered mountains

**What was added:**
1. Copied `background.png`, `backwall.png`, `parallax.png`, `foreground.png`, `map.json` to `assets/levels/frozentown_*`
2. Updated `level.js` to parse Kill Zone rectangle instances (not just a Y threshold)
3. Updated `gameplay.js`: vertical parallax scrolling, per-stage enemy layouts, kill zone death check, foreground layer rendering
4. Updated `index.html`: preloads both stages, F1/F2 switches between highway and frozentown
5. Per-stage enemy spawn positions (tanks, hoppers, birds placed at appropriate positions per stage)
6. Also imported `highway_foreground.png` which was previously missing

**Stage import standard — always copy all 5 files from the source map directory:**
1. `background.png` → `assets/levels/{name}_background.png` (main tilemap, scrolls 1:1)
2. `backwall.png` → `assets/levels/{name}_backwall.png` (behind background, scrolls 1:1)
3. `parallax.png` → `assets/levels/{name}_parallax.png` (distant layer, scrolls 0.5x)
4. `foreground.png` → `assets/levels/{name}_foreground.png` (drawn over player/enemies)
5. `map.json` → `assets/levels/{name}_map.json` (collision polygons, spawn points, kill zones)

**Note:** More stages to be imported later. The asset pipeline (`loadStage()`) loads all 5 files automatically — foreground gracefully skipped if missing.

---

### 14. Health Recovery Items (DONE)

Health pickup items that restore HP cell-by-cell, matching original MMX behavior.

**Entity:** `src/entities/health-pickup.js` — `HealthPickup` class extending `Entity`.

**Two sizes:**

| Size | Sprite Source (effects.png) | Heal Amount | Hitbox |
|------|---------------------------|-------------|--------|
| Small | y=138, h=8, frames at x=6(8w), 22(10w), 40(10w), 58(10w) | 4 HP | 8×8 |
| Large | y=150, h=12, frames at x=3(14w), 19(16w), 37(16w), 55(16w) | 8 HP | 14×12 |

**Animation:** 7-step bounce sequence [0,1,2,3,2,1,0], 2 frames per step, looping.

**Spawning:**
- **Fixed map placements**: Parsed from map.json `Large Health` / `Small Health` instances (highway: 1 small, frozentown: 3 large). No despawn timer.
- **Enemy drops**: 10% large health, then 30% small health (rolled independently). Despawns after 480 frames (8s), blinks last 120 frames (2s).

**Collection:** Player must overlap pickup AND have `hp < maxHp`. Sets pickup inactive, adds `healAmount` to `player.healQueue`.

**Heal queue:** In `gameplay.js` update, ticks +1 HP every 3 frames from `player.healQueue`. HP bar reads `player.hp` directly so it fills cell-by-cell automatically.

**Physics:** Gravity + `resolveVertical` to land on ground (same as enemies).

---

### 15. Boss Fights (DONE — Chill Penguin)

First Maverick boss fight in the frozentown stage.

**Entity:** `src/entities/chill-penguin.js` — `ChillPenguin` class extending `Entity`.
**Sprites:** All from `assets/mavericks.png` (botmid alignment).

**AI States (6):**

| State | Behavior |
|-------|----------|
| `idle` | Face player, walk toward if >120px away, countdown 40-80 frames then pick random attack |
| `shoot` | 2-frame windup → fire ice projectile (speed 4.2, damage 3, 45-frame lifetime) → idle |
| `slide` | 2-frame windup → belly slide at 5.8 px/f, bounces off walls, decelerates after 45f, stops at 75f. Has armor (no hurt interruption). Hitbox switches to 34x24 (wider, shorter) |
| `blow` | 2-frame windup → push player horizontally 2.5 px/f if in front & within 180px, lasts 96 frames → idle |
| `hurt` | 6-frame recoil (skipped during slide — armor) |
| `dying` | 8-frame explosion from effects.png |

**Key values:** 32 HP, contact damage 3 (60-frame cooldown), slide damage 3, ice shot 14x14 sprite (center-aligned, from mavericks.png at 194,232).

**Invincibility:** 45 frames (~0.75s) after taking damage, same pattern as player — `invincibleTimer` blocks damage in `onHit()`, sprite flashes (skip render every other 4 frames). Slide armor still applies on top (no hurt state interruption during slide).

**Boss HP bar:** Vertical segmented bar on right side of screen (x = SCREEN_W - 8 - 14 = 234), same BASE/FULL/EMPTY/CAP sprites as player bar from effects.png. Only shown when boss is on or near screen (64px margin via `_isBossNearScreen()`). Hidden during dying state.

**Spawn:** Configurable per-stage in `_spawnEnemies()` via `bossSpawns` object. Currently: frozentown at x=1650, y=150. Boss is stored in `this.boss` (separate from `this.enemies[]` — no health drops on boss death). Designed to be easily moved to a dedicated boss room later.

**Sprite animations (all from mavericks.png, botmid alignment):**

| Animation | Frames | Source Rects | Notes |
|-----------|--------|-------------|-------|
| idle | 2, loop | (221,77) 38x36, (43,77) 38x36 | dur=8 each |
| run | 4, loop | y=266-310, 35x37-39 | dur=6 each |
| shoot | 5, once | 2 windup + 3 shoot | POI(18,-22) on frames 2+ |
| slide | 3, once | 2 windup + (4,133) 40x31 | Slide pose held (dur=999) |
| blow | 4, loopFrom=2 | 2 windup + 2 blow | POI(23,-22), loops blow frames |
| jump | 1 | (181,127) 37x38 | ox=1 |
| fall | 1 | (60,20) 35x44 | ox=-1, oy=6 |
| land | 3, once | 3 frames | dur 4/6/4 |
| hurt | 2, loop | (175,165) 38x47, (221,169) 35x41 | dur=3 each |
| die | 1 | (221,169) 35x41 | oy=3 |

**Integration (gameplay.js):**
- Import `ChillPenguin` from `chill-penguin.js`
- Boss spawned in `_spawnEnemies()`, assigned `mavericksSprite` + `effectsSprite`
- Boss update + `checkPlayerCollision()` after enemy loop
- Separate `_checkPlayerShotsVsBoss()` method (same shot hitbox logic as enemies)
- Boss rendered between pickups and player layers
- Boss HP bar in `_renderHUD()` with screen proximity check
- Boss cleared (`this.boss = null`) when death animation finishes

**Asset pipeline:**
- `mavericks.png` copied from `MMX-Online-Deathmatch/LevelEditor/assets/spritesheets/` to `assets/`
- Loaded in `index.html` as key `'mavericksSprite'`

---

### 23. Playable Zero (DONE)

Second playable character with sword-based combat. Tab key switches between X and Zero.

**Entity:** `src/entities/zero.js` — `Zero` class extending `Player`.
**Sprites:** All from `assets/zero.png` (botmid alignment), 21 animations in `zero-sprite-data.js`.

**Architecture:**
- `Player` class refactored for subclassing: `_getAnim()` method (overridable), configurable `warpBeamRect`, exported physics constants `P`
- `Zero` extends `Player`, overrides `_getAnim()` to use `getZeroAnim()` from `zero-sprite-data.js`
- Shared state machine: warp_in, idle, run, jump, fall, land, wall_slide, dash, hurt, die
- New state: `attack` — sword combo (Zero only)

**Movement (same as X):**
- Run speed 1.5, dash speed 3.0, jump velocity -4.5, gravity 0.25
- Hitbox: 18×40 (taller than X's 18×34 due to hair)
- Warp beam: 7×55 from zero.png at (34, 1185)

**Z-Saber Combo System (shoot button):**
- Ground: 3-hit combo — `attack` → `attack2` → `attack3`
- Each swing has `atkBox` hitbox data per frame (from sprite JSON)
- Chain to next hit by pressing shoot after 40% of current swing
- Can turn between combo hits
- Air: single `attack_air` slash (no combo chain)
- Damage: slash 1-2 = 2, slash 3 = 4
- Each swing tracks which enemies were hit (no repeated damage per swing)

**Sword hitbox collision (gameplay.js):**
- `_checkSwordVsEnemies()` checks `player.swordHitbox` vs enemy/boss AABBs
- Uses same `boxOverlap()` as projectile collision
- `swordHitEnemies` Set prevents multi-hit per swing
- Debug overlay: green-yellow rect for active sword hitbox
- Hitbox uses **botmid alignment** (same as original game): box positioned with bottom-center at feet, then shifted by atkBox offset. Formula: `x = feetX - w/2 + ox*facing`, `y = feetY - h + oy`

**Character selection:**
- Tab key toggles between X and Zero (respawns with warp beam)
- `_createPlayer()` factory creates correct class + spritesheet
- `_resetPlayerAtSpawn()` creates fresh player instance

**Sprite data (auto-generated from MMX-Deathmatch JSONs via `analysis/build_zero_sprites.py`):**

| Animation | Frames | Notes |
|-----------|--------|-------|
| idle | 12, loop | ~2.5s cycle with blink pauses |
| run | 12, loop from 2 | ~0.4s per cycle |
| jump | 4, loop from 2 | Ascending pose |
| fall | 4, loop | Hair streaming up, tall frames (67h) |
| land | 2, once | 0.06s transition |
| dash | 6, loop from 2 | Wide, low profile frames |
| wall_slide | 3, once | Facing wall |
| hurt | 4, once | Recoil |
| die | 3, once | Reuses hurt frames |
| warp_in | 10, once | Materialize, 0.3s |
| warp_beam | 1 | 7×55 thin beam |
| shoot | 2, once | Buster pose |
| run_shoot | 12, loop from 2 | Run + buster arm |
| jump_shoot | 3, once | Jump + buster |
| fall_shoot | 3, loop | Fall + buster |
| dash_shoot | 6, loop from 2 | Dash + buster |
| wall_slide_shoot | 1, once | Wall + buster |
| attack | 12, once | Ground slash 1 (hitbox frames 4-7) |
| attack2 | 11, once | Ground slash 2 (hitbox frames 2-4) |
| attack3 | 15, once | Ground slash 3 (hitbox frames 4-7, massive) |
| attack_air | 9, once | Air slash (hitbox frames 4-6) |

---

### 27. Stage Select Screen (DONE)

Full-screen world map stage select, replacing the F1/F2/F4 hotkey system.

**Architecture: Dual Resolution Canvas**
- Stage select runs at **1536×1024** (native image resolution), CSS fills viewport via `object-fit: contain`
- Gameplay runs at 307×224 (unchanged), CSS fixed at 921×672
- `Game.setState()` reads `state.screenWidth`/`state.screenHeight` and resizes canvas + CSS on each state transition

**Visual:**
- Background: AI-generated pixel art world map (`assets/stage-select.png`, 1536×1024)
- Location dots: red circles on the map, selected dot turns yellow with pulse/glow animation
- Bottom banner: dark overlay over "STAGE SELECT" text, shows selected stage name in gold (`#c8a840`) with shadow
- Corner labels: "HERO" (top-left) and "EQUIP" (bottom-left) overlaid on existing panel art — decorative only for now

**Navigation:**
- D-pad/analog moves between dots using directional nearest-neighbor search (finds closest dot primarily in the pressed direction)
- Jump or Start confirms selection → transitions to GameplayState
- Escape or gamepad Select during gameplay → returns to stage select (cursor remembers last selection)

**Location Picker Tool** (`tools/stage-select-editor.html`):
- Click to place dots on the map, right-click to delete
- Edit stage key + display name per dot
- Export/import JSON — output saved to `assets/stage-locations.json`

**Files:**
- `src/states/stage-select.js` — StageSelectState class
- `tools/stage-select-editor.html` — location picker tool
- `assets/stage-select.png` — world map background
- `assets/stage-locations.json` — dot positions (4 stages: highway, frozentown, aircraftcarrier, crystalmine)
- Modified: `src/engine/game.js` (dual resolution), `src/states/gameplay.js` (Escape to return), `index.html` (boot into stage select)

---

### 26b. Fix Aircraft Carrier Stage / Custom Collision System (DONE)

The aircraft carrier stage's polygon collision data (from the MMX-Deathmatch source) produced broken tile rasterization — large invisible solid blocks in mid-air and missing ground tiles. Instead of manually editing polygon JSON, we built a full custom collision pipeline.

**Problem:** Deathmatch map.json `Collision Shape` polygons are designed for multiplayer boundaries, not platformer collision. Rasterizing them onto a 16×16 grid produces incorrect results — entire regions of solid tiles floating in the sky.

**Solution: Custom collision tile maps with variable tile size.**

**Collision Tile Editor** (`tools/collision-editor.html`):
- Visual editor to paint/erase solid tiles on top of stage background art
- Supports **16×16** (standard) and **8×8** (fine precision) tile sizes
- Click/drag to paint (D key), erase (E key), right-click to quick-erase
- "Reload from Polygons" resets to auto-rasterized state as a starting point
- Shows collision shape labels from map.json for reference
- Loads existing custom collision files automatically
- Exports compact JSON: `{ stage, tileSize, width, height, tiles: [[col,row], ...] }`

**Variable tile size support:**
- `collision.js` now reads `level.tileSize` instead of hardcoded `TILE_SIZE = 16`
- All collision functions (`isSolid`, `resolveHorizontal`, `resolveVertical`, `checkWallContact`) use `level.tileSize`
- `level.js` reads `tileSize` from custom collision data — if the JSON says `tileSize: 8`, the level uses an 8×8 grid
- Stages without custom collision keep their 16×16 polygon rasterization unchanged

**Asset loading:**
- `asset-loader.js` has a `CUSTOM_COLLISION_STAGES` whitelist (currently: `['aircraftcarrier']`)
- Only whitelisted stages fetch `{name}_collision.json` — no 404 requests for stages that don't have one
- When adding custom collision for a new stage, add its name to this list

**Stages with custom collision tiles:**

| Stage | Tile Size | File |
|-------|-----------|------|
| aircraftcarrier | 8×8 | `assets/levels/aircraftcarrier_collision.json` |

**Debug overlay enhancement:**
- P key debug mode now shows **collision shape names** (from map.json `name` property) as yellow labels at the top-left corner of each shape polygon, with dark background for readability

**Files created:**
- `tools/collision-editor.html` — visual collision tile editor
- `assets/levels/aircraftcarrier_collision.json` — custom 8×8 collision tiles for aircraft carrier

**Files modified:**
- `src/engine/collision.js` — replaced hardcoded `TILE_SIZE = 16` with `level.tileSize`
- `src/levels/level.js` — `createLevelFromMap()` accepts optional custom collision data, reads tileSize from it, stores collision shape metadata for debug
- `src/states/gameplay.js` — passes custom collision to level creation, debug overlay shows shape labels using `level.tileSize`
- `src/assets/asset-loader.js` — `CUSTOM_COLLISION_STAGES` whitelist, `loadStage()` conditionally loads collision JSON

---

### 26c. Import Crystal Mine Stage (DONE)

Imported the Crystal Mine (Crystal Snail / Energen Crystal) stage from MMX-Online-Deathmatch.

**Stage details:**
- Internal name: `crystalmine` (displayName: "energen crystal")
- Dimensions: 2032 × 830 px, killY: 925
- 39 collision shapes, 11 spawn points
- No parallax.png or foreground.png (gracefully handled — parallax load now uses `.catch(() => null)` like foreground)
- Music: `crystalmine.2,710.44,517.ogg` (loop start: 2.710s, loop end: 44.517s)

**What was added:**
1. Copied `background.png`, `backwall.png`, `map.json` to `assets/levels/crystalmine_*`
2. Copied music to `assets/music/crystalmine.2,710.44,517.ogg`
3. Added `assets.loadStage('crystalmine')` to index.html
4. Added crystalmine music to audio loading manifest in index.html
5. Added per-stage enemy layout for crystalmine in gameplay.js `_spawnEnemies()`
6. Added `crystalmine` to stage-select-editor and collision-editor dropdowns
7. Added placeholder position to `assets/stage-locations.json` (user adjusts with picker tool)
8. Made parallax loading graceful (`.catch(() => null)`) in asset-loader.js for stages without parallax

---

### 26d. Slope Collision System (DONE)

Full slope support for diagonal ground surfaces extracted from map.json collision polygons. Players, enemies, bosses, and health pickups all walk/land on slopes correctly.

**Problem:** Several stages (Frozen Town, Aircraft Carrier, Crystal Mine) have collision shapes with diagonal edges representing ramps and inclines. The tile-based AABB collision system only supports flat axis-aligned surfaces — diagonal surfaces produced "staircase" tiles that the player would get stuck on when entering or exiting.

**Solution: Three-layer slope system.**

#### Layer 1 — Slope Segment Extraction (`level.js`)

Collision shape polygons are analyzed for ground slope edges: non-axis-aligned edges whose outward normal points upward (using polygon winding to determine normal direction). These edges are extracted as slope segments with `{ x1, y1, x2, y2, slope, shapeName }` (always stored with `x1 < x2`).

Polygons that contain slope edges are **not rasterized** onto the tile grid (they would create broken staircase tiles). Instead, the slope segments are used for direct line-based collision at runtime.

**`_clearSlopeTiles()`** removes staircase tiles that other collision shapes (or custom collision data) placed in the slope area. For each column in the slope range, it clears the row above the slope surface (`slopeRow - 1`). Two key details prevent ground tile destruction:

1. **X is clamped** to the slope's endpoint range (`seg.x1` to `seg.x2`) — prevents extrapolation beyond the slope, which would compute incorrect Y values and clear ground tiles at slope endpoints (e.g., at the bottom of a downhill ramp in Frozen Town).
2. **Surface row (`slopeRow`) is never cleared** — only `slopeRow - 1` is removed. The surface row tiles are handled dynamically at runtime by `resolveSlopeHorizontal`. This preserves ground tiles at slope/flat junctions.

**Stages with slopes detected:**

| Stage | Shape | Segment | Slope Value | Notes |
|-------|-------|---------|-------------|-------|
| Frozen Town | Shape31 | (1041,350)→(1089,368) | +0.375 | Downhill ramp, 4 tile columns |
| Frozen Town | Shape30 | (1366,417)→(1431,435) | +0.277 | Gentle downhill, 5 tile columns |
| Aircraft Carrier | Shape38 | (2459,300)→(2560,248) | -0.515 | Uphill ramp, 14 tile columns |
| Crystal Mine | Shape9 | (116,385)→(817,736) | +0.501 | Massive diagonal, 89 tile columns |
| Crystal Mine | Shape22 | (1134,638)→(1196,610) | -0.452 | Short uphill section |
| Crystal Mine | Shape21 | (1230,645)→(1299,608) | -0.536 | Short uphill section |
| Crystal Mine | Shape19 | (1299,574)→(1360,544) | -0.492 | Short uphill section |
| Crystal Mine | Shape35 | (1457,499)→(1691,375) | -0.530 | Long uphill, 30 tile columns |

#### Layer 2 — Slope-Aware Vertical Resolution (`resolveSlopeVertical` in `collision.js`)

Replaces `resolveVertical` for all ground entities. Checks slope segments first, falls back to tile-based resolution.

**On-slope snapping:** When the player's foot center X is within a slope segment's range, and their feet are near the slope surface (moving down or standing), the player is snapped to the slope surface: `y = slopeY - hitboxH`. Returns `{ grounded: true, onSlope: true }`.

**Downhill snap:** When grounded and moving downhill, the feet may briefly be above the slope surface (gap < 12px). The system snaps down to keep the player glued to the slope.

**Slope→flat transition:** When leaving a slope (`wasOnSlope && !tileGrounded && dy >= 0`), the slope surface Y may not align with the tile grid, leaving a small gap. The system scans 2 rows downward from the player's feet for the nearest solid tile and snaps to it, preventing micro-drops.

**Proximity guard:** Only considers slopes within `tileSize * 2` of the player's feet (`snapMax`), preventing snapping to distant slopes above or below.

#### Layer 3 — Slope-Aware Horizontal Resolution (`resolveSlopeHorizontal` in `collision.js`)

Replaces `resolveHorizontal` for all ground entities. Allows passage through tiles at slope surfaces while preserving wall collision.

**Three zones with different skip margins:**

| Zone | Condition | Skip Margin | Purpose |
|------|-----------|-------------|---------|
| On slope | `checkX` within slope endpoints | `ts` (one tile height) | Skip staircase tiles at the slope surface |
| Transition | `checkX` within `w` beyond slope endpoints | `h` (full body height) | Skip the wall of tiles at slope/flat junctions |
| Normal | No nearby slope | 0 (no skip) | Full wall collision |

The skip condition is `cy > slopeY - skipMargin`: tiles below or near the slope surface are allowed through, tiles above are blocked normally.

**Critical: Vertical proximity check.** Before applying any slope skip logic, the function checks if the player's feet are within `tileSize * 2` of the slope surface. If not, `slopeY` is nullified and normal wall collision applies. **This is the key fix that prevents wall clipping.** Without it, large slopes like Crystal Mine's Shape9 (701px wide) would disable wall collision for every entity in their X range, even those walking on flat ground far below.

**Bugs encountered and fixed during development:**

1. **Massive wall clipping** — `resolveSlopeHorizontal` had no vertical proximity check. Any entity in the X range of a slope (even 200px below it) had wall collision disabled. Fixed by nullifying `slopeY` when `|feetY - slopeY| > tileSize * 2`.

2. **Stuck at slope/flat transitions** — Transition `skipMargin` was reduced to `ts` (one tile) which wasn't enough for the full hitbox height of tiles at junctions. Restored to `h` (full body) — safe because the proximity check prevents far-away clipping.

3. **Falling through ground at slope endpoints** — `_clearSlopeTiles` extrapolated the slope Y beyond its actual endpoints, computing incorrect surface positions that caused ground tiles to be cleared. Fixed by clamping X to `[seg.x1, seg.x2]`.

4. **Falling through at downhill ramp bottoms** — `_clearSlopeTiles` cleared the surface row tile even when it was the ground tile at the bottom of a slope. Fixed by never clearing `slopeRow` — only `slopeRow - 1`. Surface-level staircase tiles are now handled at runtime by `resolveSlopeHorizontal` with `skipMargin = ts`.

#### Entity Integration

All ground entities use slope-aware collision:

| Entity | Horizontal | Vertical | `onSlope` tracking |
|--------|-----------|----------|-------------------|
| Player (X/Zero) | `resolveSlopeHorizontal` | `resolveSlopeVertical` | Yes |
| Tank Mechaniloid | `resolveSlopeHorizontal` | `resolveSlopeVertical` | Yes |
| Hopper Mechaniloid | `resolveSlopeHorizontal` | `resolveSlopeVertical` | Yes |
| Chill Penguin (boss) | `resolveSlopeHorizontal` | `resolveSlopeVertical` | Yes (kept `resolveHorizontal` import for blow push on player) |
| Health Pickup | `resolveHorizontal` (unchanged) | `resolveSlopeVertical` | Yes |
| Bird Mechaniloid | N/A (flying) | N/A (flying) | No |

**Debug overlay:** Slope segments displayed as orange lines in debug mode (P key). `[SLOPE]` indicator shown in top-right when player is on a slope.

**Files modified:**
- `src/engine/collision.js` — Added `resolveSlopeHorizontal`, `resolveSlopeVertical`, `getSlopeGroundY`
- `src/levels/level.js` — Added `_extractSlopeSegments`, `_clearSlopeTiles`, `_isGroundSlopeEdge`, `_polygonHasSlopeEdge`, `_signedArea`; `Level` class has `slopeSegments` array
- `src/entities/player.js` — Uses slope-aware collision, tracks `onSlope`
- `src/entities/tank-enemy.js` — Uses slope-aware collision, tracks `onSlope`
- `src/entities/hopper-enemy.js` — Uses slope-aware collision, tracks `onSlope`
- `src/entities/chill-penguin.js` — Uses slope-aware collision, tracks `onSlope`
- `src/entities/health-pickup.js` — Uses slope-aware vertical, tracks `onSlope`
- `src/states/gameplay.js` — Debug overlay renders slope segments + `[SLOPE]` indicator

---

### How to Import a New Stage from MMX-Online-Deathmatch

Step-by-step procedure for adding a new stage:

**1. Locate source files**
```
MMX-Online-Deathmatch/LevelEditor/assets/maps/{stagename}/
├── background.png    (required)
├── backwall.png      (required)
├── parallax.png      (optional — some stages don't have one)
├── foreground.png    (optional — drawn over player/enemies)
├── map.json          (required — collision shapes, spawns, kill zones)
└── mirrored.json     (ignore — deathmatch mirroring data)
```

**2. Copy stage assets** to `assets/levels/`:
```bash
cp .../maps/{name}/background.png  assets/levels/{name}_background.png
cp .../maps/{name}/backwall.png    assets/levels/{name}_backwall.png
cp .../maps/{name}/parallax.png    assets/levels/{name}_parallax.png    # if exists
cp .../maps/{name}/foreground.png  assets/levels/{name}_foreground.png  # if exists
cp .../maps/{name}/map.json        assets/levels/{name}_map.json
```

**3. Copy music** — find the stage music in:
```
MMX-Online-Deathmatch/LevelEditor/assets/music/{name}.{loopStart}.{loopEnd}.ogg
```
Copy to `assets/music/` keeping the loop-point filename (audio system parses loop points from it).

**4. Update `index.html`:**
- Add `assets.loadStage('{name}')` to the stage loading Promise.all
- Add music entry to `game.audio.loadAll()`: `{name}: './assets/music/{name}.{loop}.ogg'`

**5. Update `src/states/gameplay.js`:**
- Add enemy layout for the new stage in `_spawnEnemies()` `layouts` object
- Optionally add a spawn override in `stageSpawns` if the first map spawn point isn't suitable
- The stage uses the first `Spawn Point` from map.json by default

**6. Update tool dropdowns:**
- `tools/stage-select-editor.html` — add `<option value="{name}">{name}</option>` to `#stageKey` select
- `tools/collision-editor.html` — add `<option value="{name}">{name}</option>` to `#stageSelect` select

**7. Add to stage-locations.json:**
- Add a placeholder entry: `{ "x": ..., "y": ..., "stage": "{name}", "name": "Display Name" }`
- Use the stage-select-editor tool to place the dot at the correct position on the world map

**8. Test:**
- Verify stage loads without console errors (check for 404s on missing parallax/foreground)
- Check collision shapes via debug overlay (P key)
- If collision is broken, use collision-editor to create custom tiles and add stage to `CUSTOM_COLLISION_STAGES` in `asset-loader.js`

---

### Implementation Priority

1. ~~**Shooting overlay animations**~~ — DONE (6 shoot variants)
2. ~~**Projectile spawn from POI**~~ — DONE (hand position per frame)
3. ~~**Projectile sprites**~~ — DONE (lemon + fade on wall hit)
4. ~~**ROM removal + stage assets**~~ — DONE (highway stage PNG backgrounds + polygon collision)
5. ~~**Player animation states**~~ — DONE (warp_in, land, die)
6. ~~**Dash-jump momentum**~~ — DONE (isDashing flag, 2x speed through air)
7. ~~**Charged buster shot**~~ — DONE (2 charge levels, particles, flash, animated projectiles)
8. ~~**Enemy characters**~~ — DONE (Tank Mechaniloid: patrol, chase, shoot, die)
9. ~~**More enemy types**~~ — DONE (Hopper + Bird, see below)
10. ~~**Classic MMX HP bar**~~ — DONE (segmented bar + horizontal toggle with L key)
11. ~~**Enemy damage flash + shot hit effect**~~ — DONE (white flash + buster fade on enemy hit)
12. ~~**Gamepad support**~~ — DONE (8BitDo controller, mapping tool + browser Gamepad API)
13. ~~**Import second stage map**~~ — DONE (Chill Penguin / Frozen Town, F1/F2 stage select)
14. ~~**Health recovery items**~~ — DONE (small/large pickups, 10% large + 30% small enemy drops, cell-by-cell heal queue)
15. ~~**Boss fights**~~ — DONE (Chill Penguin boss in frozentown, 3 attacks, boss HP bar)
16. ~~**Warp-in beam animation**~~ — DONE (8x48 beam sprite from XDefault.png descends 200px at 7.5px/frame, player invisible during descent, then 6-frame materialize animation)
17. ~~**Death explosion effect**~~ — DONE (spark flash + 0.75s die pose + 16-orb radial burst ×2 waves, fading over 2s, sprites from effects.png)
18. ~~**Player death → respawn flow**~~ — DONE (fade to black 40f → hold 30f → reset player/enemies/camera at spawn → fade in 40f → warp beam descent → materialize)
19. ~~**Collision system fix**~~ — DONE (switched from mergedWalls to Collision Shape instances from map.json; updated player hitbox to 18x34 matching original MMX)
20. ~~**Debug overlay**~~ — DONE (P key toggles: green collision tiles, magenta player hitbox, cyan enemy hitboxes, yellow boss hitbox, FPS + coordinates)
21. ~~**Wider viewport**~~ — DONE (internal resolution 307x224, 3x CSS scale to 921x672, ~20% more level visible horizontally)
22. ~~**Dash smoke effects**~~ — DONE (dash_sparks 4-frame puff on dash start + dust 6-frame trail during dash, from effects.png)
23. ~~**Playable Zero**~~ — DONE (see details below)
24. ~~**Collision edge-case fix**~~ — DONE (collision checks now sample every TILE_SIZE along entity height/width instead of just 2 endpoints, fixing clipping through single-row solid tiles for 34-40px tall characters; tile rasterization unchanged — center-point only)
25. ~~**Sound effects & music**~~ — DONE (Web Audio API AudioManager, 27 audio assets: X buster/charge/dash/jump/land/hurt/die, Zero saber1-3, enemies explosion, boss attacks, stage BGM with parsed loop points)
26. **Additional stages** — Import more MMX-Deathmatch stage assets. Aircraft carrier (Storm Eagle) and Crystal Mine (Crystal Snail) imported.
26b. ~~**Fix aircraft carrier stage**~~ — DONE (custom collision tile editor + 8×8 tile support, see details below)
26d. ~~**Slope collision system**~~ — DONE (3-layer slope system: segment extraction from polygons, slope-aware vertical/horizontal resolution with proximity guard, all ground entities updated. See details below)
27. ~~**Stage select screen**~~ — DONE (full-screen world map with location dots, see details below)
28. **Boss door / boss room transitions** — Shutter door animation, camera lock in boss arena, trigger zone to activate boss
29. **More bosses** — Boss entities for new stages (reuse ChillPenguin pattern)
30. **Score / lives system** — Lives counter, game over screen, score tracking
31. **Ladder climbing** — Ladder state for player (map.json already has Ladder instances), climb up/down, jump off
32. **Subtank / E-tank system** — Collectible energy tanks, use from pause menu to restore HP
33. **Boss defeat cutscene** — Boss explosion sequence, stage clear fanfare, weapon get screen
34. **Crouch** — Crouching state (sprite data exists in XDefault.png, not wired into state machine)
35. **Pause menu** — Pause screen with weapon select, subtank use, options

---

## Project Structure (Current)

```
mega-human/
├── index.html                    — Main game page (dual resolution: 1536×1024 stage select / 307×224 gameplay)
├── PLAN.md                       — This file
├── assets/
│   ├── XDefault.png              — X player spritesheet (from MMX Deathmatch)
│   ├── zero.png                  — Zero player spritesheet (from MMX Deathmatch)
│   ├── effects.png               — Projectile/VFX/HUD spritesheet (buster shots, charge particles, explosions, HP bar)
│   ├── sigma_viral.png           — Enemy spritesheet (Tank, Hopper, Bird mechaniloids)
│   ├── mavericks.png             — Maverick boss spritesheet (Chill Penguin + others)
│   ├── stage-select.png          — Stage select world map background (1536×1024)
│   ├── stage-locations.json      — Stage dot positions on world map (from picker tool)
│   ├── sounds/
│   │   ├── common/                   — Shared SFX (jump, dash, land, hurt, die, hit, explosion, etc.)
│   │   ├── mmx/                      — X buster SFX (buster.ogg, buster2-4.ogg)
│   │   ├── zero/                     — Zero saber SFX (saber1-3.ogg)
│   │   └── sigma/                    — Boss SFX (chillpBlizzard, chillpSlide, maverickDie)
│   ├── music/                        — Stage BGM with loop metadata in filenames (highway, frozentown, crystalmine, bossroom, win)
│   └── levels/
│       ├── highway_background.png    — Highway stage background layer
│       ├── highway_backwall.png      — Highway stage backwall layer
│       ├── highway_parallax.png      — Highway stage parallax layer (0.5x scroll)
│       ├── highway_map.json          — Highway stage collision polygons + spawn points
│       ├── frozentown_background.png — Frozen Town (Chill Penguin) background layer
│       ├── frozentown_backwall.png   — Frozen Town backwall layer
│       ├── frozentown_parallax.png   — Frozen Town parallax layer (0.5x X+Y scroll)
│       ├── frozentown_map.json       — Frozen Town collision polygons + spawn points
│       ├── aircraftcarrier_background.png — Aircraft Carrier background layer
│       ├── aircraftcarrier_backwall.png   — Aircraft Carrier backwall layer
│       ├── aircraftcarrier_parallax.png   — Aircraft Carrier parallax layer
│       ├── aircraftcarrier_map.json       — Aircraft Carrier collision polygons + spawn points
│       ├── aircraftcarrier_collision.json — Aircraft Carrier custom 8×8 collision tiles (overrides polygons)
│       ├── crystalmine_background.png   — Crystal Mine background layer
│       ├── crystalmine_backwall.png     — Crystal Mine backwall layer
│       └── crystalmine_map.json         — Crystal Mine collision polygons + spawn points
├── src/
│   ├── engine/
│   │   ├── game.js               — Fixed 60fps game loop, dual resolution canvas switching
│   │   ├── input.js              — Keyboard input (pressed/held/released)
│   │   ├── camera.js             — Viewport scrolling (256×224)
│   │   ├── collision.js          — Tile-based AABB collision + slope-aware resolution (variable tileSize, isSolid, resolveH/V, resolveSlopeH/V, checkWall)
│   │   └── audio.js              — Web Audio API sound manager (SFX + Music, loop points, charge loop)
│   ├── entities/
│   │   ├── entity.js             — Base entity class + AABB overlap
│   │   ├── player.js             — Player: 10-state machine, shooting, charge, dash-jump
│   │   ├── sprite-data.js        — X animation frames (19 anims) + projectile sprite data
│   │   ├── zero-sprite-data.js   — Zero animation frames (21 anims) + sword hitbox data
│   │   ├── zero.js               — Zero: extends Player, Z-Saber 3-hit combo, air slash
│   │   ├── tank-enemy.js         — Tank Mechaniloid: 5-state AI, patrol/shoot enemy
│   │   ├── hopper-enemy.js       — Hopper Mechaniloid: 4-state AI, jump/melee enemy
│   │   ├── bird-enemy.js         — Bird Mechaniloid: 3-state AI, flying/swoop enemy
│   │   ├── health-pickup.js      — Health pickup: small (4 HP) / large (8 HP), shimmer animation
│   │   └── chill-penguin.js      — Chill Penguin boss: 6-state AI, ice shot/slide/blow attacks
│   ├── states/
│   │   ├── stage-select.js      — Stage select screen (world map, location dots, navigation)
│   │   └── gameplay.js           — Gameplay state (PNG backgrounds, player, camera, HUD)
│   ├── levels/
│   │   └── level.js              — Level from map.json (polygon→tile-grid rasterizer, custom collision support)
│   └── assets/
│       └── asset-loader.js       — Image + JSON loading/caching, conditional custom collision loading
├── analysis/
│   └── build_sprite_module.py    — Generates sprite-data.js from MMX Deathmatch JSONs
├── tools/
│   ├── map-controller.py         — Gamepad mapping tool (pygame, outputs controller-map.json)
│   ├── controller-map.json       — Last generated controller mapping (8BitDo Ultimate 2C)
│   ├── stage-select-editor.html  — Location picker for stage select dots (click to place, export JSON)
│   ├── collision-editor.html     — Visual collision tile editor (paint/erase tiles, 16×16 or 8×8, export JSON)
│   ├── tile-viewer.html          — ROM tile browser (legacy)
│   ├── sprite-assembler.html     — Manual sprite assembly tool (legacy)
│   └── sprite-finder.html        — Tile search tool (legacy)
└── MMX-Online-Deathmatch/        — Reference project (NOT used at runtime)
```

---

## Key Technical Notes

**Grounded detection quirk:** `resolveVertical()` in `collision.js` only returns `grounded: true` when `dy > 0` (moving downward). If any ground state sets `this.vy = 0`, `dy` becomes 0, and `grounded` returns `false` — causing rapid state oscillation (e.g. idle → fall → land → idle) with visible shaking. **All ground states MUST apply gravity** (`this.vy += P.GRAVITY`) and let the collision system resolve the position. This was the root cause of multiple bugs during land/dash implementation.

**Sprite alignment:** All player sprites are aligned bottom-center (feet anchor). The rendering offset `ox`/`oy` is per-frame. Flip axis is always at `feetX` (character center) for left-facing sprites. Wall slide sprites face toward the wall, so flip is inverted.

**MMX dash behavior:** Original MMX has NO dash-end transition animation. X snaps directly from dash to idle/run. Early attempt to add a `dash_end` state was removed after verifying this against the MMX-Online-Deathmatch source (CharState.cs).

**Charge composite rendering:** Canvas2D `globalCompositeOperation = 'lighter'` with `globalAlpha = 0.4` creates a convincing "charge flash" without shaders. The sprite is drawn twice — once normal, once with lighter blend mode.

**Collision data source:** Map JSON contains both `mergedWalls` and `Collision Shape` instances. `mergedWalls` is for **AI pathfinding only** (6 rough polygons in frozentown). `Collision Shape` instances are the **actual collision boundaries** (43 precise rectangles in frozentown, 12 in highway). Always use `Collision Shape` instances for tile-grid rasterization.

**Player hitbox (original MMX):** The original game uses `Rect(0, 0, 18, 34)` with `botmid` alignment, meaning the hitbox is 18×34 centered horizontally on the character's feet position. Our implementation matches: `WIDTH=18, HEIGHT=34, HITBOX_X=0, HITBOX_Y=0`.

**Animation loopStart:** Some animations (dash, jump, run) have startup frames that should only play once, then loop from a later frame. The `loopStart` property on animation data specifies which frame to loop back to (default 0). The `_updateAnimation()` method in `player.js` uses `anim.loopStart || 0` when wrapping. The `build_zero_sprites.py` script reads `loopStartFrame` from the original JSONs and outputs it when > 0.

**Sword hitbox alignment (botmid):** The original MMX-Deathmatch positions sword hitboxes using botmid alignment: the box's bottom-center is placed at the character's feet, then shifted by the hitbox offset. The correct formula is `x = feetX - w/2 + ox*facing`, `y = feetY - h + oy`. An earlier bug had `y = feetY + oy` (missing the `-h` term), which placed hitboxes below the player's feet instead of at body level.

**External forces on player:** Any code that pushes the player (e.g. boss blow attack) MUST use `resolveHorizontal`/`resolveVertical` from `collision.js` — never modify `player.x`/`player.y` directly, or the player can clip through walls.

**Original MMX screen width:** The original game uses 298×224, not 256×224. Our viewport is 307×224 (~20% wider than SNES 256, slightly wider than original MMX).

**Collision check density:** `resolveHorizontal` and `checkWallContact` now check every `level.tileSize` along the entity's height, not just top+bottom endpoints. This prevents tall entities (X=34px, Zero=40px) from clipping through single-row solid tiles that fall in the middle of their hitbox. **Do NOT add extra collision tiles** to fix clipping — fix the check logic instead.

**Variable tile size collision:** `collision.js` reads `level.tileSize` instead of a hardcoded constant. Default stages use 16×16 tiles from polygon rasterization. Stages with custom collision maps can use 8×8 tiles for finer precision (half the gap, 4× the tiles). The `CUSTOM_COLLISION_STAGES` whitelist in `asset-loader.js` controls which stages load custom collision data — add the stage name there to avoid 404 requests. Custom collision JSON format: `{ stage, tileSize, width, height, tiles: [[col,row], ...] }`.

**Tile rasterization precision limit (default 16×16):** Collision shapes are rasterized onto a 16px grid using center-point checks only. Characters land on tile boundaries (multiples of 16), so there can be up to ~8px visual gap between the tile edge and the actual art. For stages where this is unacceptable, use the collision editor (`tools/collision-editor.html`) to create a custom 8×8 tile map — this reduces the gap to ~4px.

**Audio system:** `AudioManager` in `src/engine/audio.js` uses Web Audio API. AudioContext is created lazily on first user gesture (keydown/mousedown), NOT during page load. Audio files are fetched as raw ArrayBuffers during loading and decoded once the context exists. Music loop points are parsed from filenames (e.g. `highway.44,44.87,463.ogg`). Gamepad API is poll-based and cannot trigger AudioContext resume — only keyboard/mouse events work.

**Slope collision critical invariants:** (1) `resolveSlopeHorizontal` MUST check vertical proximity (`|feetY - slopeY| > ts * 2`) before applying slope skip logic — without this, large slopes disable wall collision across their entire X range. (2) `_clearSlopeTiles` MUST clamp X to the slope endpoint range and MUST NOT clear the surface row (`slopeRow`) — only clear `slopeRow - 1`. Clearing the surface row removes ground tiles at slope endpoints. (3) The on-slope `skipMargin = ts` handles surface staircase tiles at runtime, and the transition `skipMargin = h` handles the wall of tiles at slope/flat junctions.

---

## Appendix: ROM Reverse Engineering Findings

_Preserved from Plan 1.0 for reference. This data is accurate but the tile-based rendering approach was abandoned in favor of PNG spritesheets._

### Hardware: CX4 Coprocessor

The cartridge PCB is **SHVC-2DC0N-01** with a **Capcom CX4** coprocessor (Hitachi HG51B169 DSP, 20 MHz). ROM header chipset byte = `$F3` (CX4 confirmed). The CX4 is mapped at `$6000-$7FFF` in banks `$00-$3F`.

The CX4 handles:
- Player sprite DMA (tile streaming from ROM to VRAM)
- OAM table construction (assembling sprite objects from parts)
- Wireframe 3D effects (intro sequences)
- Trigonometric calculations for scaling/rotation

### Key ROM Addresses

| Address | ROM Offset | Purpose |
|---------|-----------|---------|
| `$00:80BE` | `0x0000BE` | CX4 initialization |
| `$00:A8A6` | `0x00A8A6` | Player spawn: entity type `$9D` |
| `$08:85DD` | `0x0405DD` | Entity sprite handler pointer table |
| `$08:C690` | `0x044690` | Animation controller init |
| `$08:C673` | `0x044673` | Animation tick |
| `$08:CA5C` | `0x044A5C` | CX4 sprite DMA routine |
| `$2F:D4D6` | `0x17D4D6` | Player animation base (11 anims, defs 0-18) |
| `$05:9609` | `0x029609` | Player sprite DMA transfer table (112 entries) |

### Animation System

3-byte frame format: `[duration] [flags] [sprite_def_index]`
- 11 animations, 19 sprite defs
- DMA remaps tiles 0-31 per frame, legs (64+) loaded at init
- Palette 14 at ROM `0x02BFC0`

### DMA Transfer Entry Format (6 bytes)

```
[0] Tile count (×16 = byte count)
[1] Source addr low
[2] Source addr high
[3] Source bank ($2D = player tilesheet at 0x168000)
[4] VRAM dest low
[5] VRAM dest high (bit 15 = last entry flag)
```

### 4-Block OAM Layout

```
head:   VRAM tiles (0,1,16,17)  at pixel (16, 2)
ubodyL: VRAM tiles (4,5,20,21)  at pixel (12, 16)
ubodyR: VRAM tiles (6,7,22,23)  at pixel (20, 16)
legs:   VRAM tiles (64,65,80,81) at pixel (16, 32)
```
