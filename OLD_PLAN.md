# MEGAGAME 2026: Mega Man X Browser Game

## Context

A Mega Man X-style action platformer built with plain HTML5 Canvas and JavaScript. All sprite and stage assets sourced from [MMX-Online-Deathmatch](https://github.com/gamemaker19/MMX-Online-Deathmatch), an open-source fan game with complete, high-quality PNG spritesheets and JSON animation data. Originally started as a SNES ROM port (Plan 1.0, abandoned due to CX4 coprocessor complexity).

**Goal:** A playable browser game with authentic MMX gameplay — not an emulator wrapper.

---

## Plan 1.0 — ROM-Based Sprite Extraction (ABANDONED)

### Summary

Our original approach was to extract all sprite graphics directly from the SNES ROM data, decoding tiles, palettes, and animation frames from raw ROM bytes. This involved:

1. **ROM Parsing Pipeline** — Built hex parser, LoROM mapper, 4bpp tile decoder, and SNES palette decoder. All working correctly — tiles and palettes decode fine.

2. **CX4 Coprocessor Reverse Engineering** — Disassembled the CX4 DMA sprite routine at `$08:CA5C`, decoded the DMA transfer table at `$05:$9609` (112 entries, 6-byte format), and mapped out the full animation system (11 animations, 19 sprite defs, 3-byte frame entries at `$2F:D4D6`).

3. **OAM Layout Discovery** — Decoded the CX4 sub-sprite system at `$0D:$B01E` (variable-count defs per frame, up to 31 sub-sprites), and confirmed a 4-block OAM layout: head, upper-body-left, upper-body-right, and legs.

4. **DMA Tile Remapping** — Each of the 19 sprite defs remaps VRAM tiles 0-31 to different positions in the ROM tilesheet at `0x168000`. Wrote `sprite-frames.js` with per-def tile remap tables.

### Why It Failed

**The CX4 coprocessor made this approach impractical.** The Capcom CX4 (Hitachi HG51B169 DSP) is a custom coprocessor that handles player sprite assembly at runtime. Key problems:

- **Runtime code injection**: The CX4 uploads wrapper routines to WRAM at `$7E:2680-$7E:2692` during initialization. These routines are NOT in the cartridge ROM — they're generated by the CX4 chip itself. Without emulating the CX4, we cannot reproduce these routines.

- **Complex multi-layer sprite assembly**: The CX4's Build OAM function (`op00_00`) assembles up to 31 sub-sprites per frame, including 8-9 body blocks plus 22-23 detail/effect overlays (8x8 sprites for outline details, helmet gem, buster glow, etc.). Our simplified 4-block layout captured the basic shape but missed all the detail sprites that make the character look correct.

- **Missing leg tile source**: Leg tiles (VRAM positions 64, 65, 80, 81) are loaded by a separate init mechanism not part of the main DMA table. Tiles 64-65 were found at ROM `$2F:$8D40`, but tiles 80-81 appear to be CX4-generated at runtime. We had to resort to savestate extraction as a fallback.

- **Palette runtime modification**: ROM palette 14 is correct structurally, but the game modifies palettes at runtime for charge effects, damage flashing, etc. The savestate showed palette 14 as all-zeros at the expected CGRAM position.

- **Net result**: After weeks of reverse engineering, the rendered sprites were recognizable but visually broken — wrong colors, missing detail tiles, garbled leg tiles. The CX4 does too much runtime processing to replicate from static ROM analysis alone.

### What Was Preserved

The ROM parsing pipeline was fully removed in Plan 2.1. All `src/rom/` files, `sprite-frames.js`, and `asset-map.json` have been deleted. Background rendering now uses pre-rendered PNG images from MMX-Online-Deathmatch stage assets.

All reverse engineering findings are preserved below in the **Appendix** for reference.

---

## Plan 2.0 — MMX Deathmatch Sprite Source (CURRENT)

### New Approach

We discovered [MMX-Online-Deathmatch](https://github.com/gamemaker19/MMX-Online-Deathmatch), an open-source Mega Man X fan game with complete, high-quality sprite assets. The project contains:

- **Pre-made PNG spritesheets** with all character animations laid out cleanly
- **JSON animation definitions** with precise frame rects, durations, offsets, and POI (point of interest) data for projectile spawn positions
- **Multiple character spritesheets** (X, Zero, Vile, Sigma, Axl, 26+ Mavericks)
- **Effects spritesheets** for projectiles, explosions, and other VFX

All needed assets are copied into our `assets/` folder — nothing references the `MMX-Online-Deathmatch/` directory at runtime.

### Current Status

**Player Character (X):**
- Spritesheet: `assets/XDefault.png`, 19 animations in `sprite-data.js`
- 10-state machine: warp_in, idle, run, jump, fall, land, wall_slide, dash, hurt, die
- Warp-in animation on spawn (input locked), land squash on landing (jump-cancellable)
- Dash snaps directly to idle/run on ground (no transition anim, matches original MMX)
- 6 shoot animation overlays (idle, run, jump, fall, dash, wall_slide)
- Buster projectile from `assets/effects.png` (8x6 shot, 3-frame fade on wall hit)
- Projectile spawn from hand POI (`hx`/`hy` per animation frame)
- Wall slide: sprite flipped for wall-facing, shoots away from wall
- Dash-jump momentum: `isDashing` flag preserves 2x speed through jump/fall, clears on landing
- Charged buster: hold shoot to charge (2 levels), release for bigger animated projectile
- 8 charge particles orbit player while charging, character flashes white

**Enemies:**
- Tank Mechaniloid: patrol/turn/chase/attack/dying AI, 8 HP, fires projectiles
- Sprites from `assets/sigma_viral.png`, death explosion from `assets/effects.png`
- Full collision system: player shots hit enemies, enemy shots/body hit player

**Stage:**
- Highway stage from MMX-Deathmatch PNG assets (parallax + backwall + background layers)
- Collision rasterized from map.json polygon data onto 16x16 tile grid
- Spawn points loaded from map.json instances

**Engine:**
- Fixed 60fps game loop, keyboard input with pressed/held/released edge detection
- Tile-based AABB collision, camera viewport scrolling (256x224)
- Asset loader for images + JSON, no ROM dependency

### Plan Items

---

### 1. Finish Player Sprites (DONE)

**Completed:**
- ~~`land`~~ — Landing squash animation wired into state machine (jump-cancellable)
- ~~`warp_in`~~ — Level start teleport beam plays on spawn
- ~~`die`~~ — Death animation on 0 HP
- `crouch` — Crouching (1 frame, data exists, not wired — future if we add crouch mechanic)

**Note:** `dash_end` was initially added but removed after research showed original MMX has no dash-end transition — X snaps directly to idle/run.

---

### 2. Other Character Sprites

The MMX Deathmatch project contains spritesheets for many characters. Available at `MMX-Online-Deathmatch/LevelEditor/assets/spritesheets/`:

#### Priority characters:
| Character | Spritesheet | JSON Folder | Notes |
|-----------|-------------|-------------|-------|
| **Zero** | `ZeroDefault.png` | `sprites/zero/` | Second protagonist, sword-based |
| **Vile** | `VileDefault.png` | `sprites/vile/` | Enemy/boss character |
| **Sigma** | `SigmaDefault.png` | `sprites/sigma/` | Final boss |

#### Additional characters (lower priority):
- `AxlDefault.png` — Axl (X7/X8 character)
- 26+ Maverick boss spritesheets (`CrushCrawfish.png`, `StormEagle.png`, etc.)
- Each has corresponding JSON animation definitions

#### Implementation plan:
1. Copy needed spritesheets to `assets/`
2. Run `build_sprite_module.py` (or a variant) to generate sprite-data modules for each character
3. Create entity classes extending `Entity` with character-specific state machines
4. Enemies can use simpler AI state machines (patrol, chase, attack patterns)

---

### 3. Shooting & Projectile System (DONE)

All shooting features are implemented:
- Buster shot sprites from `effects.png` (8x6 sprite, direction-aware rendering)
- 3-frame fade/hit animation on wall collision
- Hand POI-based spawn position (`hx`/`hy` per animation frame)
- Max 3 shots, 8-frame cooldown
- 6 shoot animation overlays (idle, run, jump, fall, dash, wall_slide)

---

### 4. Dash-Jump Momentum (DONE)

- `isDashing` boolean flag preserves dash speed (2x multiplier) through jump/fall states
- Set on dash entry, persists through jump-cancel and air states
- Cleared on landing (land state), wall slide, hurt, or dash expiring on ground
- Matches MMX-Online-Deathmatch behavior: speed recomputed per frame (not inertia), releasing direction = stop

---

### 5. Charged Buster Shot (DONE)

Hold shoot to charge, release for bigger projectile:
- **Charge Level 1** (0.75s / 45 frames): buster2 projectile, damage 2, speed 6.0
- **Charge Level 2** (1.75s / 105 frames): buster3 projectile, damage 3, speed 7.0
- Normal lemon fires on press, charge builds while holding, charged shot fires on release
- 8 charge particles orbit player at 24px radius, converging toward center
- Character flashes white while charging (lighter composite at 40% alpha)
- Animated projectile sprites with startup → loop → fade phases
- Charge cleared on hurt/die

Sprite sources (all from effects.png):
- buster2: 8 frames (5 startup, 3 loop), buster3: 5 frames (2 startup, 3 loop)
- charge_part_1 (level 1): 2x2 → 1x1 pixels, charge_part_2 (level 2): 4x4 → 1x1 pixels

---

### 6. Enemy Characters (DONE — Tank Mechaniloid)

First enemy implemented: **Tank Mechaniloid** from `sigma_viral.png`.

**AI State Machine (5 states):**
- `patrol` — Walk left/right within 150px of spawn, turn at ledges/walls
- `turn` — Play 1-frame turn animation (10 frames), then flip direction
- `chase` — Move toward player when spotted within 130px sight range
- `attack` — Stop and fire projectile when player is within 125px horizontal, 30px vertical
- `dying` — Play 8-frame explosion animation from effects.png, then remove

**Combat:**
- 8 HP, takes damage from player buster shots (normal and charged)
- Fires 8x7 pixel projectile (damage 2, speed 3.0, 30-frame lifetime)
- Contact damage: 3 damage on body touch (60-frame cooldown)
- Projectile spawn from POI offset (20px forward, 15px up from feet)

**Collision System (in gameplay.js):**
- Player shots vs enemies: AABB overlap check, shot destroyed on hit
- Charged shots use larger hitboxes (20x16 for level 1, 32x28 for level 2)
- Enemy shots vs player: triggers `player.takeDamage()` with knockback direction
- Enemy body vs player: contact damage with cooldown

**Sprites:** 4 animations (walk: 2 frames, turn: 1 frame, shoot: 2 frames, proj: 1 frame), all from `sigma_viral.png` row y=991-1023. Death explosion: 8 frames from `effects.png`.

---

### 9. More Enemy Types (DONE — Hopper + Bird)

#### Hopper Mechaniloid (`hopper-enemy.js`)

**AI State Machine (4 states):**
- `idle` — Waits on ground, faces player, timer before next hop
- `hop` — Jumps toward player (3-frame hop animation), lands → idle or attack
- `attack` — Melee slash when in close range (4-frame looping animation with forward hitbox)
- `dying` — 8-frame explosion from effects.png, then remove

**Combat:**
- 6 HP, takes damage from player buster shots
- Melee attack: 4 damage, 32x15 forward hitbox extending from body
- Contact damage: 3 damage on body touch (60-frame cooldown)
- Hops toward player at 1.2 px/frame, jump velocity -3.5

**Sprites:** 3 animations (idle: 1 frame, hop: 3 frames, attack: 4 frames), all from `sigma_viral.png` y=991-1021. Alignment: botmid.

#### Bird Mechaniloid (`bird-enemy.js`)

**AI State Machine (3 states):**
- `fly` — Patrols horizontally with sine-wave vertical oscillation (20px amplitude)
- `swoop` — Dives toward player position at 2.5 px/frame, then returns to patrol height
- `dying` — 8-frame explosion from effects.png, then remove

**Combat:**
- 4 HP, takes damage from player buster shots
- Contact damage: 3 damage on body touch (60-frame cooldown)
- No projectile attack — relies on swooping and body contact

**Sprites:** 1 animation (fly: 3 frames looping wing-flap), from `sigma_viral.png` y=999-1023. Alignment: center (not botmid — flying enemy doesn't anchor to ground). No tile collision.

---

### 10. Classic MMX HP Bar (DONE)

Replaced the simple rectangle health bar with the authentic MMX vertical segmented bar using sprites from `effects.png`.

**Sprite assets (all from effects.png, alignment: botmid):**

| Sprite | Source Rect (x,y → w×h) | Purpose |
|--------|------------------------|---------|
| Health base (X) | (2,55) → 14×16 | Bottom piece with character icon |
| Health full | (2,51) → 14×2 | Filled cell (one per HP point) |
| Health empty | (2,37) → 14×2 | Empty cell |
| Health top cap | (34,13) → 14×4 | Top piece capping the bar |

**Two layouts (toggle with L key):**
- **Vertical** (default) — Classic MMX style, upper-left corner, base at bottom, cells stacked upward
- **Horizontal** — Same sprites rotated 90° CW, upper-left corner, base on left, cells extending right

**Screen position:** Upper-left corner (x=8, y=8 padding).

---

### 11. Enemy Damage Flash + Shot Hit Effect (DONE)

**Enemy damage flash (white flash on hit):**
- All enemy types (Tank, Hopper, Bird) flash near-white for 6 frames (~0.1s) when hit
- Technique: `globalCompositeOperation = 'lighter'` at 0.7 alpha (same as charge flash, stronger)
- `hitFlashTimer` set to 6 in `onHit()`, decremented each frame

**Shot hit effect (buster fade on enemy hit):**
- Buster shots now play the 3-frame fade animation when hitting enemies (same as wall hits)
- Changed `shot.active = false` to `shot.fading = true` in `_checkPlayerShotsVsEnemies()`

---

### 12. Gamepad Support (DONE)

**Controller mapping tool** (`tools/map-controller.py`):
- Python/pygame script walks through each action (shoot, jump, dash, d-pad, analog stick)
- Captures axis baselines to handle controllers with non-zero trigger resting values (8BitDo triggers rest at -1.0)
- Outputs `tools/controller-map.json`

**Browser Gamepad API integration** (`src/engine/input.js`):
- Polls `navigator.getGamepads()` each frame, merges with keyboard input
- D-pad (buttons 12-15) and analog stick (axes 0/1 with 0.3 deadzone) both map to directional actions
- Note: browser button indices may differ from SDL/pygame (e.g. 8BitDo X button = SDL 2, browser 3)

---

### 13. Import Second Stage Map (DONE — Chill Penguin / Frozen Town)

Imported the Chill Penguin stage ("frozentown") from MMX-Online-Deathmatch.

**Stage details:**
- Internal name: `frozentown` (displayName: "frozen town")
- Dimensions: 1792 × 767 px (multi-tier vertical layout, much taller than highway's 224px)
- Kill zone at y=583 (death pit in the middle section)
- Parallax background with 0.5x scroll on both X and Y axes
- Purple night sky with snow-covered mountains

**What was added:**
1. Copied `background.png`, `backwall.png`, `parallax.png`, `foreground.png`, `map.json` to `assets/levels/frozentown_*`
2. Updated `level.js` to parse Kill Zone rectangle instances (not just a Y threshold)
3. Updated `gameplay.js`: vertical parallax scrolling, per-stage enemy layouts, kill zone death check, foreground layer rendering
4. Updated `index.html`: preloads both stages, F1/F2 switches between highway and frozentown
5. Per-stage enemy spawn positions (tanks, hoppers, birds placed at appropriate positions per stage)
6. Also imported `highway_foreground.png` which was previously missing

**Stage import standard — always copy all 5 files from the source map directory:**
1. `background.png` → `assets/levels/{name}_background.png` (main tilemap, scrolls 1:1)
2. `backwall.png` → `assets/levels/{name}_backwall.png` (behind background, scrolls 1:1)
3. `parallax.png` → `assets/levels/{name}_parallax.png` (distant layer, scrolls 0.5x)
4. `foreground.png` → `assets/levels/{name}_foreground.png` (drawn over player/enemies)
5. `map.json` → `assets/levels/{name}_map.json` (collision polygons, spawn points, kill zones)

**Note:** More stages to be imported later. The asset pipeline (`loadStage()`) loads required files (background, backwall, map.json) plus only the optional layers listed in `STAGE_OPTIONAL_LAYERS` in `asset-loader.js` — no fallback requests for missing files.

---

### 14. Health Recovery Items (DONE)

Health pickup items that restore HP cell-by-cell, matching original MMX behavior.

**Entity:** `src/entities/health-pickup.js` — `HealthPickup` class extending `Entity`.

**Two sizes:**

| Size | Sprite Source (effects.png) | Heal Amount | Hitbox |
|------|---------------------------|-------------|--------|
| Small | y=138, h=8, frames at x=6(8w), 22(10w), 40(10w), 58(10w) | 4 HP | 8×8 |
| Large | y=150, h=12, frames at x=3(14w), 19(16w), 37(16w), 55(16w) | 8 HP | 14×12 |

**Animation:** 7-step bounce sequence [0,1,2,3,2,1,0], 2 frames per step, looping.

**Spawning:**
- **Fixed map placements**: Parsed from map.json `Large Health` / `Small Health` instances (highway: 1 small, frozentown: 3 large). No despawn timer.
- **Enemy drops**: 10% large health, then 30% small health (rolled independently). Despawns after 480 frames (8s), blinks last 120 frames (2s).

**Collection:** Player must overlap pickup AND have `hp < maxHp`. Sets pickup inactive, adds `healAmount` to `player.healQueue`.

**Heal queue:** In `gameplay.js` update, ticks +1 HP every 3 frames from `player.healQueue`. HP bar reads `player.hp` directly so it fills cell-by-cell automatically.

**Physics:** Gravity + `resolveVertical` to land on ground (same as enemies).

---

### 15. Boss Fights (DONE — Chill Penguin)

First Maverick boss fight in the frozentown stage.

**Entity:** `src/entities/chill-penguin.js` — `ChillPenguin` class extending `Entity`.
**Sprites:** All from `assets/mavericks.png` (botmid alignment).

**AI States (6):**

| State | Behavior |
|-------|----------|
| `idle` | Face player, walk toward if >120px away, countdown 40-80 frames then pick random attack |
| `shoot` | 2-frame windup → fire ice projectile (speed 4.2, damage 3, 45-frame lifetime) → idle |
| `slide` | 2-frame windup → belly slide at 5.8 px/f, bounces off walls, decelerates after 45f, stops at 75f. Has armor (no hurt interruption). Hitbox switches to 34x24 (wider, shorter) |
| `blow` | 2-frame windup → push player horizontally 2.5 px/f if in front & within 180px, lasts 96 frames → idle |
| `hurt` | 6-frame recoil (skipped during slide — armor) |
| `dying` | 8-frame explosion from effects.png |

**Key values:** 32 HP, contact damage 3 (60-frame cooldown), slide damage 3, ice shot 14x14 sprite (center-aligned, from mavericks.png at 194,232).

**Invincibility:** 45 frames (~0.75s) after taking damage, same pattern as player — `invincibleTimer` blocks damage in `onHit()`, sprite flashes (skip render every other 4 frames). Slide armor still applies on top (no hurt state interruption during slide).

**Boss HP bar:** Vertical segmented bar on right side of screen (x = SCREEN_W - 8 - 14 = 234), same BASE/FULL/EMPTY/CAP sprites as player bar from effects.png. Only shown when boss is on or near screen (64px margin via `_isBossNearScreen()`). Hidden during dying state.

**Spawn:** Configurable per-stage in `_spawnEnemies()` via `bossSpawns` object. Currently: frozentown at x=1650, y=150. Boss is stored in `this.boss` (separate from `this.enemies[]` — no health drops on boss death). Designed to be easily moved to a dedicated boss room later.

**Sprite animations (all from mavericks.png, botmid alignment):**

| Animation | Frames | Source Rects | Notes |
|-----------|--------|-------------|-------|
| idle | 2, loop | (221,77) 38x36, (43,77) 38x36 | dur=8 each |
| run | 4, loop | y=266-310, 35x37-39 | dur=6 each |
| shoot | 5, once | 2 windup + 3 shoot | POI(18,-22) on frames 2+ |
| slide | 3, once | 2 windup + (4,133) 40x31 | Slide pose held (dur=999) |
| blow | 4, loopFrom=2 | 2 windup + 2 blow | POI(23,-22), loops blow frames |
| jump | 1 | (181,127) 37x38 | ox=1 |
| fall | 1 | (60,20) 35x44 | ox=-1, oy=6 |
| land | 3, once | 3 frames | dur 4/6/4 |
| hurt | 2, loop | (175,165) 38x47, (221,169) 35x41 | dur=3 each |
| die | 1 | (221,169) 35x41 | oy=3 |

**Integration (gameplay.js):**
- Import `ChillPenguin` from `chill-penguin.js`
- Boss spawned in `_spawnEnemies()`, assigned `mavericksSprite` + `effectsSprite`
- Boss update + `checkPlayerCollision()` after enemy loop
- Separate `_checkPlayerShotsVsBoss()` method (same shot hitbox logic as enemies)
- Boss rendered between pickups and player layers
- Boss HP bar in `_renderHUD()` with screen proximity check
- Boss cleared (`this.boss = null`) when death animation finishes

**Asset pipeline:**
- `mavericks.png` copied from `MMX-Online-Deathmatch/LevelEditor/assets/spritesheets/` to `assets/`
- Loaded in `index.html` as key `'mavericksSprite'`

---

### 23. Playable Zero (DONE)

Second playable character with sword-based combat. Tab key switches between X and Zero.

**Entity:** `src/entities/zero.js` — `Zero` class extending `Player`.
**Sprites:** All from `assets/zero.png` (botmid alignment), 21 animations in `zero-sprite-data.js`.

**Architecture:**
- `Player` class refactored for subclassing: `_getAnim()` method (overridable), configurable `warpBeamRect`, exported physics constants `P`
- `Zero` extends `Player`, overrides `_getAnim()` to use `getZeroAnim()` from `zero-sprite-data.js`
- Shared state machine: warp_in, idle, run, jump, fall, land, wall_slide, dash, hurt, die
- New state: `attack` — sword combo (Zero only)

**Movement (same as X):**
- Run speed 1.5, dash speed 3.0, jump velocity -4.5, gravity 0.25
- Hitbox: 18×40 (taller than X's 18×34 due to hair)
- Warp beam: 7×55 from zero.png at (34, 1185)

**Z-Saber Combo System (shoot button):**
- Ground: 3-hit combo — `attack` → `attack2` → `attack3`
- Each swing has `atkBox` hitbox data per frame (from sprite JSON)
- Chain to next hit by pressing shoot after 40% of current swing
- Can turn between combo hits
- Air: single `attack_air` slash (no combo chain)
- Damage: slash 1-2 = 2, slash 3 = 4
- Each swing tracks which enemies were hit (no repeated damage per swing)

**Sword hitbox collision (gameplay.js):**
- `_checkSwordVsEnemies()` checks `player.swordHitbox` vs enemy/boss AABBs
- Uses same `boxOverlap()` as projectile collision
- `swordHitEnemies` Set prevents multi-hit per swing
- Debug overlay: green-yellow rect for active sword hitbox
- Hitbox uses **botmid alignment** (same as original game): box positioned with bottom-center at feet, then shifted by atkBox offset. Formula: `x = feetX - w/2 + ox*facing`, `y = feetY - h + oy`

**Character selection:**
- Tab key toggles between X and Zero (respawns with warp beam)
- `_createPlayer()` factory creates correct class + spritesheet
- `_resetPlayerAtSpawn()` creates fresh player instance

**Sprite data (auto-generated from MMX-Deathmatch JSONs via `analysis/build_zero_sprites.py`):**

| Animation | Frames | Notes |
|-----------|--------|-------|
| idle | 12, loop | ~2.5s cycle with blink pauses |
| run | 12, loop from 2 | ~0.4s per cycle |
| jump | 4, loop from 2 | Ascending pose |
| fall | 4, loop | Hair streaming up, tall frames (67h) |
| land | 2, once | 0.06s transition |
| dash | 6, loop from 2 | Wide, low profile frames |
| wall_slide | 3, once | Facing wall |
| hurt | 4, once | Recoil |
| die | 3, once | Reuses hurt frames |
| warp_in | 10, once | Materialize, 0.3s |
| warp_beam | 1 | 7×55 thin beam |
| shoot | 2, once | Buster pose |
| run_shoot | 12, loop from 2 | Run + buster arm |
| jump_shoot | 3, once | Jump + buster |
| fall_shoot | 3, loop | Fall + buster |
| dash_shoot | 6, loop from 2 | Dash + buster |
| wall_slide_shoot | 1, once | Wall + buster |
| attack | 12, once | Ground slash 1 (hitbox frames 4-7) |
| attack2 | 11, once | Ground slash 2 (hitbox frames 2-4) |
| attack3 | 15, once | Ground slash 3 (hitbox frames 4-7, massive) |
| attack_air | 9, once | Air slash (hitbox frames 4-6) |

---

### 26f. Import Sigma Stage 2 (DONE)

Imported the Sigma Stage 2 from MMX-Online-Deathmatch.

**Stage details:**
- Internal name: `sigma2` (displayName: "sigma stage 2")
- Dimensions: 2466 × 256 px (wide, short)
- 19 collision shapes, 2 kill zones, 10 spawn points
- Player spawn override: (100, 80)
- Music: `sigma2.0.61,373.ogg` (loop start: 0s, loop end: 61.373s)
- Has parallax.png, no foreground.png

**Files added:**
- `assets/levels/sigma2_background.png`, `sigma2_backwall.png`, `sigma2_parallax.png`, `sigma2_map.json`
- `assets/music/sigma2.0.61,373.ogg`

**Code changes:**
- `index.html`: stage loading + music entry
- `gameplay.js`: spawn override + enemy layout
- `tools/stage-select-editor.html` + `collision-editor.html`: dropdown options
- NOT added to `stage-locations.json` — user places dot manually via editor tool

---

### 36. Playable Sigma (DONE)

Third playable character with beam saber combat. Tab key cycles X → Zero → Sigma.

**Entity:** `src/entities/sigma.js` — `Sigma` class extending `Player`.
**Sprites:** All from `assets/sigma.png` (sigma_x1 from MMX-Deathmatch, botmid alignment), 17 animations in `sigma-sprite-data.js`.

**Architecture:**
- `Sigma` extends `Player`, overrides `_getAnim()`, `_groundState()`, `_airState()`, `_dashState()`, `_wallSlideState()`, `_handleShooting()`, `_attackState()`, `render()`
- No buster or charge — `_handleShooting()` is a no-op, shoot button always triggers sword attacks
- No combo chain (one ground slash), but has ground/air/dash/wall slide attack variants
- Sword collision reuses existing `_checkSwordVsEnemies()` system (same as Zero)

**Hitbox:** 28×52 (larger than X's 18×34 and Zero's 18×40)
**Warp beam:** 58×60 capsule effect from sigma.png at (192, 3) — visually distinct from X/Zero's thin beams

**Beam Saber Attacks (shoot button):**

| Attack | Trigger | Damage | Animation | Notes |
|--------|---------|--------|-----------|-------|
| Ground slash | Shoot (idle/run) | 3 | `attack` 4f (2 windup, 1 swing, 1 hold) | Slow forward movement during attack |
| Air slash | Shoot (jump/fall) | 3 | `attack_air` 4f | Mid-air downward slash |
| Dash slash | Shoot during dash | 4 | `attack_dash` 2f | Carries dash momentum, direction locked |
| Wall slash | Shoot during wall slide | 3 | `wall_slide_attack` 12f (atkBox frames 3-6) | Stays on wall, sprite faces wall via facing flip |

**atkBox values (manually tuned by user):**
- Ground: `{w:23, h:40, ox:30, oy:-32}` — narrow, tall, far forward
- Air: `{w:23, h:40, ox:23, oy:-42}` — same shape, higher up
- Dash: `{w:23, h:40, ox:21, oy:-33}` — similar to ground
- Wall: `{w:48, h:53, ox:53, oy:3}` — wide, extends far from wall

**Wall slide attack implementation:**
- `_wallSlideState()` override checks shoot press → `_startWallSlideAttack()`
- Preserves `wallContact` in `_wallAttackContact` for physics and rendering
- `_attackState()` handles wall attack: `vy = WALL_SLIDE_SPEED`, `vx = 0`, facing away from wall
- After animation finishes, returns to `wall_slide` state (restores wallContact)
- Render override: temporarily flips `facing` toward wall so base Player render draws sprite facing wall correctly (NOT by changing state — that caused a bug where `_getAnim('wall_slide')` returned wrong animation)

**Bug found and fixed:** Initial render approach temporarily set `this.state = 'wall_slide'` during render so the base class flip logic would apply. But this caused `_getAnim('wall_slide')` to be called instead of `_getAnim('attack')`, returning the 3-frame wall_slide animation instead of the 12-frame wall_slide_attack. With `animFrame > 2`, the modulo wrapped and the animation visually looped rapidly. Fix: flip `this.facing` toward the wall instead of changing state.

**Character selection:**
- Tab key cycles: X → Zero → Sigma → X (array-based rotation in gameplay.js)
- `_createPlayer()` factory creates `Sigma` class with `sigmaSprite` image

**Sprite data (auto-generated via `analysis/build_sigma_sprites.py`):**

| Animation | Frames | Notes |
|-----------|--------|-------|
| idle | 4, loop | Caped stance |
| run | 10, loop | Fast run cycle |
| jump | 1, once | Ascending pose |
| fall | 1, loop | Same as jump |
| land | 1, once | Landing squash |
| dash | 1, loop | Low dash pose |
| wall_slide | 3, once | Facing wall |
| hurt | 4, once | Recoil |
| die | 1, once | Death pose |
| warp_in | 6, once | Capsule materialize |
| warp_beam | 1 | 58×60 warp capsule |
| shoot | 2, loop | Projectile firing pose (for future proj_slash) |
| attack | 4, once | Ground slash (atkBox frames 2-3) |
| attack_air | 4, once | Air slash (atkBox frames 2-3) |
| attack_dash | 2, once | Dash slash (atkBox frames 0-1) |
| wall_slide_attack | 12, once | Wall slash (atkBox frames 3-6) |
| proj_slash | 1, once | Energy wave projectile sprite (79×50, for future use) |

**Asset pipeline:**
- `sigma.png` (sigma_x1.png) copied from MMX-Deathmatch spritesheets to `assets/`
- Loaded in `index.html` as key `'sigmaSprite'`
- `build_sigma_sprites.py` generates sprite data with `MANUAL_ATK_BOXES` and `MANUAL_DURATIONS` overrides

---

### 37. Sigma Additional Attacks (NOT STARTED)

Additional attack animations available from MMX-Deathmatch JSONs, not yet wired into the playable character:

**High priority:**

| Attack | JSON Source | Description | Implementation |
|--------|------------|-------------|----------------|
| **Projectile slash** | `sigma_shoot.json` + `sigma_proj_slash.json` | Energy wave ranged attack (79×50 sprite). `shoot` anim has POI spawn positions. | Fire projectile entity from hand POI during a new "shoot" state. Gives Sigma his only ranged attack. |
| **Block/Guard** | `sigma_block.json` | Defensive stance with 4 shield hitboxes. | New `block` state on a dedicated button. Reduce incoming damage while blocking. |

**Medium priority:**

| Attack | JSON Source | Description | Implementation |
|--------|------------|-------------|----------------|
| **Wall dash** | `sigma_wall_dash.json` | Dash along wall (1 frame hold). | New movement option while wall sliding + directional input. |
| **Wall dash attack** | `sigma_wall_dash_attack.json` | Slash during wall dash (2 frames). | Extension of wall dash, press shoot during wall dash. |
| **Wall kick** | `sigma_wall_kick.json` | Kick off wall (3 frames). | Alternative to wall jump with different trajectory/damage. |

**Low priority:**

| Attack | JSON Source | Description | Implementation |
|--------|------------|-------------|----------------|
| **Ladder attack** | `sigma_ladder_attack.json` | Slash on ladder (11 frames, hitbox on frame 4: 36×55). | Requires ladder climbing system (#31) first. |
| **Cloak** | `sigma_cloak.json` | Cloaking ability. | Stealth mechanic, reduce visibility to enemies. |
| **Summon Maverick** | `sigma_summon_maverick.json` | Summon a Maverick ally. | Complex — spawn a temporary AI ally. |

---

### 38. Sigma CPU AI / Enemy Sigma (NOT STARTED)

Sigma as a boss/enemy entity controlled by AI, inspired by the CPU AI system in MMX-Online-Deathmatch.

**Concept:** The original MMX-Deathmatch has a full CPU AI system that controls characters in deathmatch mode — making movement decisions, choosing attacks based on distance/situation, and reacting to the player. We want to port this for Sigma as an enemy encounter.

**Research needed:**
- Study `MMX-Online-Deathmatch/` source for CPU AI logic (likely in C# files under a `AI/` or `CPU/` directory)
- Identify the decision-making system: distance-based attack selection, movement patterns, aggression levels
- Determine how the AI selects between: approach, retreat, attack, jump, dash, block

**Implementation plan:**

1. **SigmaEnemy class** — New entity extending `Entity` (NOT `Player`), similar to `ChillPenguin` boss pattern but using Sigma's full moveset
   - Uses `sigma.png` spritesheet and `SIGMA_ANIMATIONS` from `sigma-sprite-data.js`
   - Full AI state machine: idle, chase, attack, dash, jump, wall_slide, hurt, dying
   - All sword attacks available: ground slash, air slash, dash slash, wall slash, projectile slash

2. **AI Decision System:**
   - **Distance-based:** Choose attack type based on range to player
     - Close range (< 40px): ground slash or dash slash
     - Medium range (40-120px): approach or projectile slash
     - Far range (> 120px): dash toward player or projectile slash
   - **Situational:** React to player position
     - Player above: jump + air slash
     - Player on wall: wall dash attack
     - Low HP: more aggressive, use projectile slash more
   - **Cooldowns:** Prevent attack spam, add idle windows between attacks

3. **Combat values:**
   - HP: 32+ (boss-tier)
   - Ground slash: 3 damage, air slash: 3, dash slash: 4, projectile slash: 2
   - Contact damage: 3 (60-frame cooldown)
   - Invincibility frames after hit: 45 frames

4. **Spawn:** Configurable per-stage, can be used as a boss or as a recurring enemy encounter (e.g., Sigma stages)

5. **Reuse existing systems:**
   - Sword hitbox collision via `_checkSwordVsEnemies()` pattern (enemy version)
   - Boss HP bar rendering
   - Death explosion from effects.png
   - Enemy shot system for projectile slash

---

### 27. Stage Select Screen (DONE)

Full-screen world map stage select, replacing the F1/F2/F4 hotkey system.

**Architecture: Dual Resolution Canvas**
- Stage select runs at **1536×1024** (native image resolution), CSS fills viewport via `object-fit: contain`
- Gameplay runs at 307×224 (unchanged), CSS fixed at 921×672
- `Game.setState()` reads `state.screenWidth`/`state.screenHeight` and resizes canvas + CSS on each state transition

**Visual:**
- Background: AI-generated pixel art world map (`assets/stage-select.png`, 1536×1024)
- Location dots: red circles on the map, selected dot turns yellow with pulse/glow animation
- Bottom banner: dark overlay over "STAGE SELECT" text, shows selected stage name in gold (`#c8a840`) with shadow
- Corner labels: "HERO" (top-left) and "EQUIP" (bottom-left) overlaid on existing panel art — decorative only for now

**Navigation:**
- D-pad/analog moves between dots using directional nearest-neighbor search (finds closest dot primarily in the pressed direction)
- Jump or Start confirms selection → transitions to GameplayState
- Escape or gamepad Select during gameplay → returns to stage select (cursor remembers last selection)

**Location Picker Tool** (`tools/stage-select-editor.html`):
- Click to place dots on the map, right-click to delete
- Edit stage key + display name per dot
- Export/import JSON — output saved to `assets/stage-locations.json`

**Files:**
- `src/states/stage-select.js` — StageSelectState class
- `tools/stage-select-editor.html` — location picker tool
- `assets/stage-select.png` — world map background
- `assets/stage-locations.json` — dot positions (4 stages: highway, frozentown, aircraftcarrier, crystalmine)
- Modified: `src/engine/game.js` (dual resolution), `src/states/gameplay.js` (Escape to return), `index.html` (boot into stage select)

---

### 26b. Fix Aircraft Carrier Stage / Custom Collision System (DONE)

The aircraft carrier stage's polygon collision data (from the MMX-Deathmatch source) produced broken tile rasterization — large invisible solid blocks in mid-air and missing ground tiles. Instead of manually editing polygon JSON, we built a full custom collision pipeline.

**Problem:** Deathmatch map.json `Collision Shape` polygons are designed for multiplayer boundaries, not platformer collision. Rasterizing them onto a 16×16 grid produces incorrect results — entire regions of solid tiles floating in the sky.

**Solution: Custom collision tile maps with variable tile size.**

**Collision Tile Editor** (`tools/collision-editor.html`):
- Visual editor to paint/erase solid tiles on top of stage background art
- Supports **16×16** (standard) and **8×8** (fine precision) tile sizes
- Click/drag to paint (D key), erase (E key), right-click to quick-erase
- "Reload from Polygons" resets to auto-rasterized state as a starting point
- Shows collision shape labels from map.json for reference
- Loads existing custom collision files automatically
- Exports compact JSON: `{ stage, tileSize, width, height, tiles: [[col,row], ...] }`

**Variable tile size support:**
- `collision.js` now reads `level.tileSize` instead of hardcoded `TILE_SIZE = 16`
- All collision functions (`isSolid`, `resolveHorizontal`, `resolveVertical`, `checkWallContact`) use `level.tileSize`
- `level.js` reads `tileSize` from custom collision data — if the JSON says `tileSize: 8`, the level uses an 8×8 grid
- Stages without custom collision keep their 16×16 polygon rasterization unchanged

**Asset loading:**
- `asset-loader.js` has a `CUSTOM_COLLISION_STAGES` whitelist (currently: `['aircraftcarrier']`)
- Only whitelisted stages fetch `{name}_collision.json` — no 404 requests for stages that don't have one
- When adding custom collision for a new stage, add its name to this list

**Stages with custom collision tiles:**

| Stage | Tile Size | File |
|-------|-----------|------|
| aircraftcarrier | 8×8 | `assets/levels/aircraftcarrier_collision.json` |

**Debug overlay enhancement:**
- P key debug mode now shows **collision shape names** (from map.json `name` property) as yellow labels at the top-left corner of each shape polygon, with dark background for readability

**Files created:**
- `tools/collision-editor.html` — visual collision tile editor
- `assets/levels/aircraftcarrier_collision.json` — custom 8×8 collision tiles for aircraft carrier

**Files modified:**
- `src/engine/collision.js` — replaced hardcoded `TILE_SIZE = 16` with `level.tileSize`
- `src/levels/level.js` — `createLevelFromMap()` accepts optional custom collision data, reads tileSize from it, stores collision shape metadata for debug
- `src/states/gameplay.js` — passes custom collision to level creation, debug overlay shows shape labels using `level.tileSize`
- `src/assets/asset-loader.js` — `CUSTOM_COLLISION_STAGES` whitelist, `loadStage()` conditionally loads collision JSON

---

### 26c. Import Crystal Mine Stage (DONE)

Imported the Crystal Mine (Crystal Snail / Energen Crystal) stage from MMX-Online-Deathmatch.

**Stage details:**
- Internal name: `crystalmine` (displayName: "energen crystal")
- Dimensions: 2032 × 830 px, killY: 925
- 39 collision shapes, 11 spawn points
- No parallax.png or foreground.png (gracefully handled — parallax load now uses `.catch(() => null)` like foreground)
- Music: `crystalmine.2,710.44,517.ogg` (loop start: 2.710s, loop end: 44.517s)

**What was added:**
1. Copied `background.png`, `backwall.png`, `map.json` to `assets/levels/crystalmine_*`
2. Copied music to `assets/music/crystalmine.2,710.44,517.ogg`
3. Added `assets.loadStage('crystalmine')` to index.html
4. Added crystalmine music to audio loading manifest in index.html
5. Added per-stage enemy layout for crystalmine in gameplay.js `_spawnEnemies()`
6. Added `crystalmine` to stage-select-editor and collision-editor dropdowns
7. Added placeholder position to `assets/stage-locations.json` (user adjusts with picker tool)
8. Made parallax loading graceful (`.catch(() => null)`) in asset-loader.js for stages without parallax

---

### 26d. Slope Collision System (DONE)

Full slope support for diagonal ground surfaces extracted from map.json collision polygons. Players, enemies, bosses, and health pickups all walk/land on slopes correctly.

**Problem:** Several stages (Frozen Town, Aircraft Carrier, Crystal Mine) have collision shapes with diagonal edges representing ramps and inclines. The tile-based AABB collision system only supports flat axis-aligned surfaces — diagonal surfaces produced "staircase" tiles that the player would get stuck on when entering or exiting.

**Solution: Three-layer slope system.**

#### Layer 1 — Slope Segment Extraction (`level.js`)

Collision shape polygons are analyzed for ground slope edges: non-axis-aligned edges whose outward normal points upward (using polygon winding to determine normal direction). These edges are extracted as slope segments with `{ x1, y1, x2, y2, slope, shapeName }` (always stored with `x1 < x2`).

Polygons that contain slope edges are **not rasterized** onto the tile grid (they would create broken staircase tiles). Instead, the slope segments are used for direct line-based collision at runtime.

**`_clearSlopeTiles()`** removes staircase tiles that other collision shapes (or custom collision data) placed in the slope area. For each column in the slope range, it clears the row above the slope surface (`slopeRow - 1`). Two key details prevent ground tile destruction:

1. **X is clamped** to the slope's endpoint range (`seg.x1` to `seg.x2`) — prevents extrapolation beyond the slope, which would compute incorrect Y values and clear ground tiles at slope endpoints (e.g., at the bottom of a downhill ramp in Frozen Town).
2. **Surface row (`slopeRow`) is never cleared** — only `slopeRow - 1` is removed. The surface row tiles are handled dynamically at runtime by `resolveSlopeHorizontal`. This preserves ground tiles at slope/flat junctions.

**Stages with slopes detected:**

| Stage | Shape | Segment | Slope Value | Notes |
|-------|-------|---------|-------------|-------|
| Frozen Town | Shape31 | (1041,350)→(1089,368) | +0.375 | Downhill ramp, 4 tile columns |
| Frozen Town | Shape30 | (1366,417)→(1431,435) | +0.277 | Gentle downhill, 5 tile columns |
| Aircraft Carrier | Shape38 | (2459,300)→(2560,248) | -0.515 | Uphill ramp, 14 tile columns |
| Crystal Mine | Shape9 | (116,385)→(817,736) | +0.501 | Massive diagonal, 89 tile columns |
| Crystal Mine | Shape22 | (1134,638)→(1196,610) | -0.452 | Short uphill section |
| Crystal Mine | Shape21 | (1230,645)→(1299,608) | -0.536 | Short uphill section |
| Crystal Mine | Shape19 | (1299,574)→(1360,544) | -0.492 | Short uphill section |
| Crystal Mine | Shape35 | (1457,499)→(1691,375) | -0.530 | Long uphill, 30 tile columns |

#### Layer 2 — Slope-Aware Vertical Resolution (`resolveSlopeVertical` in `collision.js`)

Replaces `resolveVertical` for all ground entities. Checks slope segments first, falls back to tile-based resolution.

**On-slope snapping:** When the player's foot center X is within a slope segment's range, and their feet are near the slope surface (moving down or standing), the player is snapped to the slope surface: `y = slopeY - hitboxH`. Returns `{ grounded: true, onSlope: true }`.

**Downhill snap:** When grounded and moving downhill, the feet may briefly be above the slope surface (gap < 12px). The system snaps down to keep the player glued to the slope.

**Slope→flat transition:** When leaving a slope (`wasOnSlope && !tileGrounded && dy >= 0`), the slope surface Y may not align with the tile grid, leaving a small gap. The system scans 2 rows downward from the player's feet for the nearest solid tile and snaps to it, preventing micro-drops.

**Proximity guard:** Only considers slopes within `tileSize * 2` of the player's feet (`snapMax`), preventing snapping to distant slopes above or below.

#### Layer 3 — Slope-Aware Horizontal Resolution (`resolveSlopeHorizontal` in `collision.js`)

Replaces `resolveHorizontal` for all ground entities. Allows passage through tiles at slope surfaces while preserving wall collision.

**Three zones with different skip margins:**

| Zone | Condition | Skip Margin | Purpose |
|------|-----------|-------------|---------|
| On slope | `checkX` within slope endpoints | `ts` (one tile height) | Skip staircase tiles at the slope surface |
| Transition | `checkX` within `w` beyond slope endpoints | `h` (full body height) | Skip the wall of tiles at slope/flat junctions |
| Normal | No nearby slope | 0 (no skip) | Full wall collision |

The skip condition is `cy > slopeY - skipMargin`: tiles below or near the slope surface are allowed through, tiles above are blocked normally.

**Critical: Vertical proximity check.** Before applying any slope skip logic, the function checks if the player's feet are within `tileSize * 2` of the slope surface. If not, `slopeY` is nullified and normal wall collision applies. **This is the key fix that prevents wall clipping.** Without it, large slopes like Crystal Mine's Shape9 (701px wide) would disable wall collision for every entity in their X range, even those walking on flat ground far below.

**Bugs encountered and fixed during development:**

1. **Massive wall clipping** — `resolveSlopeHorizontal` had no vertical proximity check. Any entity in the X range of a slope (even 200px below it) had wall collision disabled. Fixed by nullifying `slopeY` when `|feetY - slopeY| > tileSize * 2`.

2. **Stuck at slope/flat transitions** — Transition `skipMargin` was reduced to `ts` (one tile) which wasn't enough for the full hitbox height of tiles at junctions. Restored to `h` (full body) — safe because the proximity check prevents far-away clipping.

3. **Falling through ground at slope endpoints** — `_clearSlopeTiles` extrapolated the slope Y beyond its actual endpoints, computing incorrect surface positions that caused ground tiles to be cleared. Fixed by clamping X to `[seg.x1, seg.x2]`.

4. **Falling through at downhill ramp bottoms** — `_clearSlopeTiles` cleared the surface row tile even when it was the ground tile at the bottom of a slope. Fixed by never clearing `slopeRow` — only `slopeRow - 1`. Surface-level staircase tiles are now handled at runtime by `resolveSlopeHorizontal` with `skipMargin = ts`.

#### Entity Integration

All ground entities use slope-aware collision:

| Entity | Horizontal | Vertical | `onSlope` tracking |
|--------|-----------|----------|-------------------|
| Player (X/Zero) | `resolveSlopeHorizontal` | `resolveSlopeVertical` | Yes |
| Tank Mechaniloid | `resolveSlopeHorizontal` | `resolveSlopeVertical` | Yes |
| Hopper Mechaniloid | `resolveSlopeHorizontal` | `resolveSlopeVertical` | Yes |
| Chill Penguin (boss) | `resolveSlopeHorizontal` | `resolveSlopeVertical` | Yes (kept `resolveHorizontal` import for blow push on player) |
| Health Pickup | `resolveHorizontal` (unchanged) | `resolveSlopeVertical` | Yes |
| Bird Mechaniloid | N/A (flying) | N/A (flying) | No |

**Debug overlay:** Slope segments displayed as orange lines in debug mode (P key). `[SLOPE]` indicator shown in top-right when player is on a slope.

**Files modified:**
- `src/engine/collision.js` — Added `resolveSlopeHorizontal`, `resolveSlopeVertical`, `getSlopeGroundY`
- `src/levels/level.js` — Added `_extractSlopeSegments`, `_clearSlopeTiles`, `_isGroundSlopeEdge`, `_polygonHasSlopeEdge`, `_signedArea`; `Level` class has `slopeSegments` array
- `src/entities/player.js` — Uses slope-aware collision, tracks `onSlope`
- `src/entities/tank-enemy.js` — Uses slope-aware collision, tracks `onSlope`
- `src/entities/hopper-enemy.js` — Uses slope-aware collision, tracks `onSlope`
- `src/entities/chill-penguin.js` — Uses slope-aware collision, tracks `onSlope`
- `src/entities/health-pickup.js` — Uses slope-aware vertical, tracks `onSlope`
- `src/states/gameplay.js` — Debug overlay renders slope segments + `[SLOPE]` indicator

---

### How to Import a New Stage from MMX-Online-Deathmatch

Step-by-step procedure for adding a new stage:

**1. Locate source files**
```
MMX-Online-Deathmatch/LevelEditor/assets/maps/{stagename}/
├── background.png    (required)
├── backwall.png      (required)
├── parallax.png      (optional — some stages don't have one)
├── foreground.png    (optional — drawn over player/enemies)
├── map.json          (required — collision shapes, spawns, kill zones)
└── mirrored.json     (ignore — deathmatch mirroring data)
```

**2. Copy stage assets** to `assets/levels/`:
```bash
cp .../maps/{name}/background.png  assets/levels/{name}_background.png
cp .../maps/{name}/backwall.png    assets/levels/{name}_backwall.png
cp .../maps/{name}/parallax.png    assets/levels/{name}_parallax.png    # if exists
cp .../maps/{name}/foreground.png  assets/levels/{name}_foreground.png  # if exists
cp .../maps/{name}/map.json        assets/levels/{name}_map.json
```

**3. Update `STAGE_OPTIONAL_LAYERS`** in `src/assets/asset-loader.js`:
- Add an entry for the new stage listing which optional layers were copied (from: `parallax`, `parallax2`, `parallax3`, `foreground`)
- Only list layers that actually exist as files — the loader will NOT attempt to load unlisted layers (no `.catch(() => null)` fallback)
- Example: `mystage: ['parallax', 'foreground'],` or `mystage: [],` if none exist
- `background`, `backwall`, and `map.json` are always loaded (not optional)

**4. Copy music** — find the stage music in:
```
MMX-Online-Deathmatch/LevelEditor/assets/music/{name}.{loopStart}.{loopEnd}.ogg
```
Copy to `assets/music/` keeping the loop-point filename (audio system parses loop points from it).

**5. Update `index.html`:**
- Add `assets.loadStage('{name}')` to the stage loading Promise.all
- Add music entry to `game.audio.loadAll()`: `{name}: './assets/music/{name}.{loop}.ogg'`

**6. Update `src/states/gameplay.js`:**
- Add enemy layout for the new stage in `_spawnEnemies()` `layouts` object
- Optionally add a spawn override in `stageSpawns` if the first map spawn point isn't suitable
- The stage uses the first `Spawn Point` from map.json by default

**7. Update tool dropdowns:**
- `tools/stage-select-editor.html` — add `<option value="{name}">{name}</option>` to `#stageKey` select
- `tools/collision-editor.html` — add `<option value="{name}">{name}</option>` to `#stageSelect` select

**8. Add to stage-locations.json:**
- Add a placeholder entry: `{ "x": ..., "y": ..., "stage": "{name}", "name": "Display Name" }`
- Use the stage-select-editor tool to place the dot at the correct position on the world map

**9. Test:**
- Verify stage loads without console errors (no 404s — if you see any, check `STAGE_OPTIONAL_LAYERS` in `asset-loader.js`)
- Check collision shapes via debug overlay (P key)
- If collision is broken, use collision-editor to create custom tiles and add stage to `CUSTOM_COLLISION_STAGES` in `asset-loader.js`

---

### 26e. Weather Control Stage Import (IN PROGRESS — SLOPE COLLISION BROKEN)

Imported the Weather Control (Storm Owl) stage from MMX-Online-Deathmatch. The stage loaded fine, but its collision polygons exposed a fundamental limitation in our slope collision system that remains **unresolved after 6+ fix attempts**.

**Stage details:**
- Internal name: `weathercontrol`
- Dimensions: 3328 × 256 px (very wide, short)
- 50 collision shapes, 3 kill zones, 11 spawn points
- Multiple slope polygons that contain BOTH the slope surface AND solid ground beneath them
- Music: `weathercontrol.0,1.49,946.ogg`

**Files added during import:**
- `assets/levels/weathercontrol_background.png`
- `assets/levels/weathercontrol_backwall.png`
- `assets/levels/weathercontrol_parallax.png`
- `assets/levels/weathercontrol_foreground.png`
- `assets/levels/weathercontrol_map.json`
- `assets/music/weathercontrol.0,1.49,946.ogg`

**Code changes for import:**
- `index.html`: Added `assets.loadStage('weathercontrol')` and music entry
- `src/states/gameplay.js`: Added weathercontrol enemy layout, spawn override `weathercontrol: { x: 130, y: 90 }`
- `assets/stage-locations.json`: Added weathercontrol dot at (648, 397)
- `tools/stage-select-editor.html`: Added weathercontrol dropdown
- `tools/collision-editor.html`: Added weathercontrol dropdown

---

#### THE SLOPE COLLISION BUG — Full History of Attempts

**ROOT CAUSE:** Weather control's slope polygons are structured differently from existing stages. In frozen town/aircraft carrier/crystal mine, slope polygons are mostly just the slope surface. But weather control has polygons where the slope is the TOP EDGE of a large polygon that also contains the solid ground beneath. The existing code marked these polygons as "has slope" and then **entirely skipped their rasterization** (the old `if (!customCollision && !hasSlope)` check on line 130 of level.js). This deleted all ground tiles under the slopes.

**WHAT WAS WORKING BEFORE WEATHER CONTROL:** All existing stages (highway, frozentown, aircraftcarrier, crystalmine) had correct slope collision. The system had:
1. `level.js`: Slope polygons entirely skipped from rasterization, `_clearSlopeTiles()` removed staircase tiles from adjacent shapes at slopeRow-1
2. `collision.js`: `resolveSlopeHorizontal` with `w`-pixel extension beyond endpoints, `h` transition margin, `ts*2` proximity guard
3. `collision.js`: `resolveSlopeVertical` with slope→flat transition scan

---

**ATTEMPT 1 — Rasterize slope polygons normally**
- **Change:** Changed `if (!customCollision && !hasSlope)` to `if (!customCollision)` on line 130 of level.js, so slope polygons ARE rasterized
- **Result:** Ground under slopes preserved in weather control! But introduced TWO new bugs:
  - **Bug 1 (wall clipping):** At the start of weather control, near the beginning of a slope, the player could clip through solid blocks/walls. The `resolveSlopeHorizontal` transition zone (extending `w` pixels = 18px beyond slope endpoints, with `h` = 34px skip margin) was disabling wall collision for blocks adjacent to slope endpoints.
  - **Bug 2 (missing tile):** At the junction between Shape10 and Shape11, a collision tile was missing. `_clearSlopeTiles()` was damaging tiles from non-slope shapes that shared columns with slope shapes.
- **Why it failed:** Rasterizing the slope polygon body created staircase tiles at the slope surface, which then interacted badly with `resolveSlopeHorizontal`'s transition zones.

---

**ATTEMPT 2 — Two-pass rasterization + directional transition**
- **Changes:**
  1. `level.js`: Rasterize slope polygons FIRST, then call `_clearSlopeTiles()`, then rasterize non-slope polygons (so `_clearSlopeTiles` can't damage non-slope shapes)
  2. `collision.js`: Made the transition zone directional — only apply the `h` skip margin when moving TOWARD the slope (approaching from flat to slope), not when moving away
- **Result:** Fixed Bug 2 (non-slope shapes no longer damaged). But introduced **Bug 3:**
  - **Bug 3 (stuck at slope→flat):** When walking UP a slope and transitioning to flat ground, the player got stuck at the slope endpoint. The directional check meant: when the leading edge was past the slope endpoint and the player was moving AWAY from the slope, the transition zone was disabled. But the player's feet were still being snapped to the slope by `resolveSlopeVertical`, creating a conflict where vertical said "you're on the slope" but horizontal said "you can't pass through these tiles."
- **Why it failed:** The slope→flat transition requires the skip margin in BOTH directions, not just the approach direction. The player needs to walk through the wall of tiles at the junction regardless of which direction they're coming from.

---

**ATTEMPT 3 — feetOnSlope check**
- **Change:** Added a `feetOnSlope` boolean: if the player's foot center X is within the slope segment's [x1, x2] range, always allow the full transition zone (bypass the directional check)
- **Result:** User reported "this created more bugs" — likely caused issues on other stages where the player's feet could be "on slope" by X coordinate but standing on flat ground above/below the slope, leading to false transition zone activation.
- **Why it failed:** The X-range check alone isn't sufficient — the player could be at the right X but on a different Y level entirely (e.g., standing on a platform above the slope).

---

**AT THIS POINT: User nuked all collision changes and asked me to research original MMX-Online-Deathmatch source.**

**Research findings:** The original game uses DIRECT POLYGON COLLISION (not tile rasterization). Collision is tested as polygon-vs-hitbox intersection. Slopes use a `pushIncline` mechanism: when the player's hitbox intersects a slope polygon, the engine computes the surface normal and pushes the player upward along the normal. There are no tiles, no staircase artifacts, no transition zones. Our tile-based system is fundamentally different and can't replicate this approach without a major rewrite.

---

**ATTEMPT 4 — _rasterizeSlopePolygon (clean approach inspired by original)**
- **Changes:**
  1. `level.js`: NEW function `_rasterizeSlopePolygon()` that rasterizes the polygon body BUT skips tiles at `slopeRow` and `slopeRow-1` (the two rows at the slope surface). This preserves ground below slopes while avoiding staircase artifacts at the surface.
  2. `level.js`: Removed `_clearSlopeTiles()` entirely (no longer needed since surface tiles are handled by the new function)
  3. `collision.js`: Simplified `resolveSlopeHorizontal` — removed `w` extension, kept strict [x1, x2] range only
- **Result:** Weather control ground preserved, no staircase artifacts. But TWO new bugs:
  - **Weather control wall shaking:** Standing on flat ground near a slope endpoint and pressing against a wall caused screen shaking. The old proximity guard (`ts * 2` = 32px) was too loose — the player's feet at y=176 were 21px from slopeY=155, which passed the check (21 < 32) and activated slope skip logic, disabling wall collision.
  - **Aircraft carrier stuck:** Player got stuck at slope transitions on aircraft carrier. This stage uses CUSTOM COLLISION (hand-painted tiles). `_clearSlopeTiles()` was needed to clear staircase tiles from the custom collision data near slope surfaces. Removing it broke aircraft carrier.
- **Why it partially failed:** (a) Proximity guard too loose for weather control's geometry. (b) Custom collision stages still need `_clearSlopeTiles`.

---

**ATTEMPT 5 — Remove extension entirely (strict slope range)**
- **Change:** In `resolveSlopeHorizontal`, changed the slope detection from `checkX >= seg.x1 - w && checkX <= seg.x2 + w` to `checkX >= seg.x1 && checkX <= seg.x2` (no extension at all)
- **Result:** "all transitions are bugged now" — removing the extension means there's NO transition zone. At every slope→flat junction, there's a column of solid tiles (from the flat ground polygon) that the player can't walk through. The slope surface handles the Y position, but the X collision hits the wall of tiles at the junction. Without the `w`-pixel extension and `h` skip margin, the player gets stuck at EVERY slope endpoint.
- **Why it failed:** The extension IS needed. The problem isn't the extension — it's the PROXIMITY GUARD being too loose. The extension should stay but should only activate when the player is actually near the slope surface.

---

**ATTEMPT 6 — Tighten proximity guard only (current state, UNTESTED)**
- **Changes:**
  1. `collision.js`: Restored the ORIGINAL `resolveSlopeHorizontal` exactly as it was before all weather control changes (with `w` extension, `h` transition margin, `inTransition` flag), but tightened the proximity guard from `ts * 2` (32px) to `ts` (16px).
  2. `level.js`: Still has `_rasterizeSlopePolygon` from Attempt 4. Still MISSING the `_clearSlopeTiles` call (removed in Attempt 4, never restored).
- **Theory:** The weather control wall-shaking bug was caused by the proximity guard being 32px instead of 16px. At the problem location, the player's feet are ~21px from the slope surface. With `ts*2=32`: 21 < 32 → slope activated (BUG). With `ts=16`: 21 > 16 → slope nullified (FIXED). Meanwhile all the actual slope transitions have feet within ~0-8px of the slope surface, so the tighter guard shouldn't affect them.
- **INCOMPLETE:** The `_clearSlopeTiles` call still needs to be restored in level.js for aircraft carrier / crystal mine (custom collision stages with slopes). The function body was removed from the file entirely in Attempt 4 and needs to be brought back.
- **Status:** User said "you have one extra shot" and then context was lost due to compaction. This fix was NEVER TESTED.

---

#### CURRENT FILE STATE (repo nuked — back to original pre-weather-control state):

**`src/levels/level.js` — ORIGINAL (no weather control changes):**
- Line 129-134: Slope polygons ARE rasterized with `_rasterizePolygon()` (same as non-slope). No `_rasterizeSlopePolygon` function exists.
- Line 155-158: `_clearSlopeTiles()` IS called — clears slopeRow-1 tiles for each slope segment
- This is the version that works for frozentown, aircraftcarrier, crystalmine but causes weather control to have staircase artifacts at slope surfaces (the ground beneath IS preserved since slope polygons are rasterized normally)

**`src/engine/collision.js` — ORIGINAL (no weather control changes):**
- Line 117: Proximity guard is `ts * 2` (32px) — the original value
- `resolveSlopeHorizontal` has `w`-extension, `h` transition margin, `inTransition` flag — all original
- This is the version that works for all existing stages but causes wall-clipping/shaking on weather control near slope endpoints (because `ts*2` is too loose for WC's geometry)

---

#### WHAT NEEDS TO HAPPEN TO FIX THIS (theory, untested):

1. **Restore `_clearSlopeTiles()`** in level.js — both the function and its call after tile rasterization. This is needed for custom collision stages (aircraft carrier, crystal mine) where hand-painted tiles create staircase artifacts at slopes.

2. **Keep `_rasterizeSlopePolygon()`** — this correctly preserves ground under slopes while skipping surface tiles. Weather control needs this.

3. **Keep the tightened proximity guard** (`ts` instead of `ts*2`) — this should prevent false slope activation on weather control's pillars near slope endpoints.

4. **Test ALL stages:** highway (no slopes), frozentown (2 slopes), aircraftcarrier (1 slope, custom collision), crystalmine (5 slopes), weathercontrol (new, multiple slopes). Every slope entry/exit transition must work in both directions.

#### KEY INSIGHT FOR FUTURE FIXING:
The fundamental tension is: `resolveSlopeHorizontal` needs to skip tiles at slope/flat junctions (otherwise player gets stuck), but it must NOT skip tiles at walls that happen to be near a slope endpoint. The proximity guard (checking if feet are near the slope surface) is the ONLY thing separating these two cases. Getting the proximity threshold right is critical — too loose (32px) and walls near slopes break, too tight (maybe 8px?) and transitions break.

#### ALTERNATIVE APPROACHES NOT YET TRIED:
1. **Custom collision for weather control** — Add `weathercontrol` to `CUSTOM_COLLISION_STAGES` in asset-loader.js and paint the tiles manually. This completely sidesteps the rasterization problem. The slope system would still handle slopes (extracted from map.json), but the ground tiles would be hand-placed.
2. **Polygon-based collision** — Replace the tile grid with direct polygon intersection testing (like the original game). Major rewrite, would solve all slope issues but break everything temporarily.
3. **Hybrid approach** — Use polygon collision only for slope polygons, tile collision for everything else. Less invasive than a full rewrite.

---

### Implementation Priority

1. ~~**Shooting overlay animations**~~ — DONE (6 shoot variants)
2. ~~**Projectile spawn from POI**~~ — DONE (hand position per frame)
3. ~~**Projectile sprites**~~ — DONE (lemon + fade on wall hit)
4. ~~**ROM removal + stage assets**~~ — DONE (highway stage PNG backgrounds + polygon collision)
5. ~~**Player animation states**~~ — DONE (warp_in, land, die)
6. ~~**Dash-jump momentum**~~ — DONE (isDashing flag, 2x speed through air)
7. ~~**Charged buster shot**~~ — DONE (2 charge levels, particles, flash, animated projectiles)
8. ~~**Enemy characters**~~ — DONE (Tank Mechaniloid: patrol, chase, shoot, die)
9. ~~**More enemy types**~~ — DONE (Hopper + Bird, see below)
10. ~~**Classic MMX HP bar**~~ — DONE (segmented bar + horizontal toggle with L key)
11. ~~**Enemy damage flash + shot hit effect**~~ — DONE (white flash + buster fade on enemy hit)
12. ~~**Gamepad support**~~ — DONE (8BitDo controller, mapping tool + browser Gamepad API)
13. ~~**Import second stage map**~~ — DONE (Chill Penguin / Frozen Town, F1/F2 stage select)
14. ~~**Health recovery items**~~ — DONE (small/large pickups, 10% large + 30% small enemy drops, cell-by-cell heal queue)
15. ~~**Boss fights**~~ — DONE (Chill Penguin boss in frozentown, 3 attacks, boss HP bar)
16. ~~**Warp-in beam animation**~~ — DONE (8x48 beam sprite from XDefault.png descends 200px at 7.5px/frame, player invisible during descent, then 6-frame materialize animation)
17. ~~**Death explosion effect**~~ — DONE (spark flash + 0.75s die pose + 16-orb radial burst ×2 waves, fading over 2s, sprites from effects.png)
18. ~~**Player death → respawn flow**~~ — DONE (fade to black 40f → hold 30f → reset player/enemies/camera at spawn → fade in 40f → warp beam descent → materialize)
19. ~~**Collision system fix**~~ — DONE (switched from mergedWalls to Collision Shape instances from map.json; updated player hitbox to 18x34 matching original MMX)
20. ~~**Debug overlay**~~ — DONE (P key toggles: green collision tiles, magenta player hitbox, cyan enemy hitboxes, yellow boss hitbox, FPS + coordinates)
21. ~~**Wider viewport**~~ — DONE (internal resolution 307x224, 3x CSS scale to 921x672, ~20% more level visible horizontally)
22. ~~**Dash smoke effects**~~ — DONE (dash_sparks 4-frame puff on dash start + dust 6-frame trail during dash, from effects.png)
23. ~~**Playable Zero**~~ — DONE (see details below)
24. ~~**Collision edge-case fix**~~ — DONE (collision checks now sample every TILE_SIZE along entity height/width instead of just 2 endpoints, fixing clipping through single-row solid tiles for 34-40px tall characters; tile rasterization unchanged — center-point only)
25. ~~**Sound effects & music**~~ — DONE (Web Audio API AudioManager, 27 audio assets: X buster/charge/dash/jump/land/hurt/die, Zero saber1-3, enemies explosion, boss attacks, stage BGM with parsed loop points)
26. **Additional stages** — Import more MMX-Deathmatch stage assets. Aircraft carrier (Storm Eagle) and Crystal Mine (Crystal Snail) imported.
26b. ~~**Fix aircraft carrier stage**~~ — DONE (custom collision tile editor + 8×8 tile support, see details below)
26d. ~~**Slope collision system**~~ — DONE (3-layer slope system: segment extraction from polygons, slope-aware vertical/horizontal resolution with proximity guard, all ground entities updated. See details below)
27. ~~**Stage select screen**~~ — DONE (full-screen world map with location dots, see details below)
26f. ~~**Import Sigma Stage 2**~~ — DONE (sigma2 stage, 2466×256, wide layout)
28. **Boss door / boss room transitions** — Shutter door animation, camera lock in boss arena, trigger zone to activate boss
29. **More bosses** — Boss entities for new stages (reuse ChillPenguin pattern)
30. **Score / lives system** — Lives counter, game over screen, score tracking
31. **Ladder climbing** — Ladder state for player (map.json already has Ladder instances), climb up/down, jump off
32. **Subtank / E-tank system** — Collectible energy tanks, use from pause menu to restore HP
33. **Boss defeat cutscene** — Boss explosion sequence, stage clear fanfare, weapon get screen
34. **Crouch** — Crouching state (sprite data exists in XDefault.png, not wired into state machine)
35. **Pause menu** — Pause screen with weapon select, subtank use, options
36. ~~**Playable Sigma**~~ — DONE (third playable character, beam saber, 4 attack variants, see details below)
37. **Sigma additional attacks** — Projectile slash (ranged), block/guard, wall dash attacks (see details below)
38. **Sigma CPU AI / Enemy Sigma** — AI-controlled Sigma as boss/enemy encounter (see details below)

---

## Project Structure (Current)

```
mega-human/
├── index.html                    — Main game page (dual resolution: 1536×1024 stage select / 307×224 gameplay)
├── PLAN.md                       — This file
├── assets/
│   ├── XDefault.png              — X player spritesheet (from MMX Deathmatch)
│   ├── zero.png                  — Zero player spritesheet (from MMX Deathmatch)
│   ├── sigma.png                 — Sigma player spritesheet (sigma_x1 from MMX Deathmatch)
│   ├── effects.png               — Projectile/VFX/HUD spritesheet (buster shots, charge particles, explosions, HP bar)
│   ├── sigma_viral.png           — Enemy spritesheet (Tank, Hopper, Bird mechaniloids)
│   ├── mavericks.png             — Maverick boss spritesheet (Chill Penguin + others)
│   ├── stage-select.png          — Stage select world map background (1536×1024)
│   ├── stage-locations.json      — Stage dot positions on world map (from picker tool)
│   ├── sounds/
│   │   ├── common/                   — Shared SFX (jump, dash, land, hurt, die, hit, explosion, etc.)
│   │   ├── mmx/                      — X buster SFX (buster.ogg, buster2-4.ogg)
│   │   ├── zero/                     — Zero saber SFX (saber1-3.ogg)
│   │   └── sigma/                    — Boss SFX (chillpBlizzard, chillpSlide, maverickDie)
│   ├── music/                        — Stage BGM with loop metadata in filenames (highway, frozentown, crystalmine, bossroom, win)
│   └── levels/
│       ├── highway_background.png    — Highway stage background layer
│       ├── highway_backwall.png      — Highway stage backwall layer
│       ├── highway_parallax.png      — Highway stage parallax layer (0.5x scroll)
│       ├── highway_map.json          — Highway stage collision polygons + spawn points
│       ├── frozentown_background.png — Frozen Town (Chill Penguin) background layer
│       ├── frozentown_backwall.png   — Frozen Town backwall layer
│       ├── frozentown_parallax.png   — Frozen Town parallax layer (0.5x X+Y scroll)
│       ├── frozentown_map.json       — Frozen Town collision polygons + spawn points
│       ├── aircraftcarrier_background.png — Aircraft Carrier background layer
│       ├── aircraftcarrier_backwall.png   — Aircraft Carrier backwall layer
│       ├── aircraftcarrier_parallax.png   — Aircraft Carrier parallax layer
│       ├── aircraftcarrier_map.json       — Aircraft Carrier collision polygons + spawn points
│       ├── aircraftcarrier_collision.json — Aircraft Carrier custom 8×8 collision tiles (overrides polygons)
│       ├── crystalmine_background.png   — Crystal Mine background layer
│       ├── crystalmine_backwall.png     — Crystal Mine backwall layer
│       ├── crystalmine_map.json         — Crystal Mine collision polygons + spawn points
│       ├── sigma2_background.png        — Sigma Stage 2 background layer
│       ├── sigma2_backwall.png          — Sigma Stage 2 backwall layer
│       ├── sigma2_parallax.png          — Sigma Stage 2 parallax layer
│       └── sigma2_map.json              — Sigma Stage 2 collision polygons + spawn points
├── src/
│   ├── engine/
│   │   ├── game.js               — Fixed 60fps game loop, dual resolution canvas switching
│   │   ├── input.js              — Keyboard input (pressed/held/released)
│   │   ├── camera.js             — Viewport scrolling (256×224)
│   │   ├── collision.js          — Tile-based AABB collision + slope-aware resolution (variable tileSize, isSolid, resolveH/V, resolveSlopeH/V, checkWall)
│   │   └── audio.js              — Web Audio API sound manager (SFX + Music, loop points, charge loop)
│   ├── entities/
│   │   ├── entity.js             — Base entity class + AABB overlap
│   │   ├── player.js             — Player: 10-state machine, shooting, charge, dash-jump
│   │   ├── sprite-data.js        — X animation frames (19 anims) + projectile sprite data
│   │   ├── zero-sprite-data.js   — Zero animation frames (21 anims) + sword hitbox data
│   │   ├── zero.js               — Zero: extends Player, Z-Saber 3-hit combo, air slash
│   │   ├── sigma-sprite-data.js  — Sigma animation frames (17 anims) + sword hitbox data
│   │   ├── sigma.js              — Sigma: extends Player, beam saber, 4 attack variants
│   │   ├── tank-enemy.js         — Tank Mechaniloid: 5-state AI, patrol/shoot enemy
│   │   ├── hopper-enemy.js       — Hopper Mechaniloid: 4-state AI, jump/melee enemy
│   │   ├── bird-enemy.js         — Bird Mechaniloid: 3-state AI, flying/swoop enemy
│   │   ├── health-pickup.js      — Health pickup: small (4 HP) / large (8 HP), shimmer animation
│   │   └── chill-penguin.js      — Chill Penguin boss: 6-state AI, ice shot/slide/blow attacks
│   ├── states/
│   │   ├── stage-select.js      — Stage select screen (world map, location dots, navigation)
│   │   └── gameplay.js           — Gameplay state (PNG backgrounds, player, camera, HUD)
│   ├── levels/
│   │   └── level.js              — Level from map.json (polygon→tile-grid rasterizer, custom collision support)
│   └── assets/
│       └── asset-loader.js       — Image + JSON loading/caching, conditional custom collision loading
├── analysis/
│   ├── build_sprite_module.py    — Generates sprite-data.js from MMX Deathmatch JSONs
│   ├── build_zero_sprites.py     — Generates zero-sprite-data.js from Zero JSONs
│   └── build_sigma_sprites.py    — Generates sigma-sprite-data.js from Sigma JSONs
├── tools/
│   ├── map-controller.py         — Gamepad mapping tool (pygame, outputs controller-map.json)
│   ├── controller-map.json       — Last generated controller mapping (8BitDo Ultimate 2C)
│   ├── stage-select-editor.html  — Location picker for stage select dots (click to place, export JSON)
│   ├── collision-editor.html     — Visual collision tile editor (paint/erase tiles, 16×16 or 8×8, export JSON)
│   ├── tile-viewer.html          — ROM tile browser (legacy)
│   ├── sprite-assembler.html     — Manual sprite assembly tool (legacy)
│   └── sprite-finder.html        — Tile search tool (legacy)
└── MMX-Online-Deathmatch/        — Reference project (NOT used at runtime)
```

---

## Key Technical Notes

**Grounded detection quirk:** `resolveVertical()` in `collision.js` only returns `grounded: true` when `dy > 0` (moving downward). If any ground state sets `this.vy = 0`, `dy` becomes 0, and `grounded` returns `false` — causing rapid state oscillation (e.g. idle → fall → land → idle) with visible shaking. **All ground states MUST apply gravity** (`this.vy += P.GRAVITY`) and let the collision system resolve the position. This was the root cause of multiple bugs during land/dash implementation.

**Sprite alignment:** All player sprites are aligned bottom-center (feet anchor). The rendering offset `ox`/`oy` is per-frame. Flip axis is always at `feetX` (character center) for left-facing sprites. Wall slide sprites face toward the wall, so flip is inverted.

**MMX dash behavior:** Original MMX has NO dash-end transition animation. X snaps directly from dash to idle/run. Early attempt to add a `dash_end` state was removed after verifying this against the MMX-Online-Deathmatch source (CharState.cs).

**Charge composite rendering:** Canvas2D `globalCompositeOperation = 'lighter'` with `globalAlpha = 0.4` creates a convincing "charge flash" without shaders. The sprite is drawn twice — once normal, once with lighter blend mode.

**Collision data source:** Map JSON contains both `mergedWalls` and `Collision Shape` instances. `mergedWalls` is for **AI pathfinding only** (6 rough polygons in frozentown). `Collision Shape` instances are the **actual collision boundaries** (43 precise rectangles in frozentown, 12 in highway). Always use `Collision Shape` instances for tile-grid rasterization.

**Player hitbox (original MMX):** The original game uses `Rect(0, 0, 18, 34)` with `botmid` alignment, meaning the hitbox is 18×34 centered horizontally on the character's feet position. Our implementation matches: `WIDTH=18, HEIGHT=34, HITBOX_X=0, HITBOX_Y=0`.

**Animation loopStart:** Some animations (dash, jump, run) have startup frames that should only play once, then loop from a later frame. The `loopStart` property on animation data specifies which frame to loop back to (default 0). The `_updateAnimation()` method in `player.js` uses `anim.loopStart || 0` when wrapping. The `build_zero_sprites.py` script reads `loopStartFrame` from the original JSONs and outputs it when > 0.

**Sword hitbox alignment (botmid):** The original MMX-Deathmatch positions sword hitboxes using botmid alignment: the box's bottom-center is placed at the character's feet, then shifted by the hitbox offset. The correct formula is `x = feetX - w/2 + ox*facing`, `y = feetY - h + oy`. An earlier bug had `y = feetY + oy` (missing the `-h` term), which placed hitboxes below the player's feet instead of at body level.

**External forces on player:** Any code that pushes the player (e.g. boss blow attack) MUST use `resolveHorizontal`/`resolveVertical` from `collision.js` — never modify `player.x`/`player.y` directly, or the player can clip through walls.

**Original MMX screen width:** The original game uses 298×224, not 256×224. Our viewport is 307×224 (~20% wider than SNES 256, slightly wider than original MMX).

**Collision check density:** `resolveHorizontal` and `checkWallContact` now check every `level.tileSize` along the entity's height, not just top+bottom endpoints. This prevents tall entities (X=34px, Zero=40px) from clipping through single-row solid tiles that fall in the middle of their hitbox. **Do NOT add extra collision tiles** to fix clipping — fix the check logic instead.

**Variable tile size collision:** `collision.js` reads `level.tileSize` instead of a hardcoded constant. Default stages use 16×16 tiles from polygon rasterization. Stages with custom collision maps can use 8×8 tiles for finer precision (half the gap, 4× the tiles). The `CUSTOM_COLLISION_STAGES` whitelist in `asset-loader.js` controls which stages load custom collision data — add the stage name there to avoid 404 requests. Custom collision JSON format: `{ stage, tileSize, width, height, tiles: [[col,row], ...] }`.

**Tile rasterization precision limit (default 16×16):** Collision shapes are rasterized onto a 16px grid using center-point checks only. Characters land on tile boundaries (multiples of 16), so there can be up to ~8px visual gap between the tile edge and the actual art. For stages where this is unacceptable, use the collision editor (`tools/collision-editor.html`) to create a custom 8×8 tile map — this reduces the gap to ~4px.

**Audio system:** `AudioManager` in `src/engine/audio.js` uses Web Audio API. AudioContext is created lazily on first user gesture (keydown/mousedown), NOT during page load. Audio files are fetched as raw ArrayBuffers during loading and decoded once the context exists. Music loop points are parsed from filenames (e.g. `highway.44,44.87,463.ogg`). Gamepad API is poll-based and cannot trigger AudioContext resume — only keyboard/mouse events work.

**Slope collision critical invariants:** (1) `resolveSlopeHorizontal` MUST check vertical proximity (`|feetY - slopeY| > ts * 2`) before applying slope skip logic — without this, large slopes disable wall collision across their entire X range. (2) `_clearSlopeTiles` MUST clamp X to the slope endpoint range and MUST NOT clear the surface row (`slopeRow`) — only clear `slopeRow - 1`. Clearing the surface row removes ground tiles at slope endpoints. (3) The on-slope `skipMargin = ts` handles surface staircase tiles at runtime, and the transition `skipMargin = h` handles the wall of tiles at slope/flat junctions.

---

## Appendix: ROM Reverse Engineering Findings

_Preserved from Plan 1.0 for reference. This data is accurate but the tile-based rendering approach was abandoned in favor of PNG spritesheets._

### Hardware: CX4 Coprocessor

The cartridge PCB is **SHVC-2DC0N-01** with a **Capcom CX4** coprocessor (Hitachi HG51B169 DSP, 20 MHz). ROM header chipset byte = `$F3` (CX4 confirmed). The CX4 is mapped at `$6000-$7FFF` in banks `$00-$3F`.

The CX4 handles:
- Player sprite DMA (tile streaming from ROM to VRAM)
- OAM table construction (assembling sprite objects from parts)
- Wireframe 3D effects (intro sequences)
- Trigonometric calculations for scaling/rotation

### Key ROM Addresses

| Address | ROM Offset | Purpose |
|---------|-----------|---------|
| `$00:80BE` | `0x0000BE` | CX4 initialization |
| `$00:A8A6` | `0x00A8A6` | Player spawn: entity type `$9D` |
| `$08:85DD` | `0x0405DD` | Entity sprite handler pointer table |
| `$08:C690` | `0x044690` | Animation controller init |
| `$08:C673` | `0x044673` | Animation tick |
| `$08:CA5C` | `0x044A5C` | CX4 sprite DMA routine |
| `$2F:D4D6` | `0x17D4D6` | Player animation base (11 anims, defs 0-18) |
| `$05:9609` | `0x029609` | Player sprite DMA transfer table (112 entries) |

### Animation System

3-byte frame format: `[duration] [flags] [sprite_def_index]`
- 11 animations, 19 sprite defs
- DMA remaps tiles 0-31 per frame, legs (64+) loaded at init
- Palette 14 at ROM `0x02BFC0`

### DMA Transfer Entry Format (6 bytes)

```
[0] Tile count (×16 = byte count)
[1] Source addr low
[2] Source addr high
[3] Source bank ($2D = player tilesheet at 0x168000)
[4] VRAM dest low
[5] VRAM dest high (bit 15 = last entry flag)
```

### 4-Block OAM Layout

```
head:   VRAM tiles (0,1,16,17)  at pixel (16, 2)
ubodyL: VRAM tiles (4,5,20,21)  at pixel (12, 16)
ubodyR: VRAM tiles (6,7,22,23)  at pixel (20, 16)
legs:   VRAM tiles (64,65,80,81) at pixel (16, 32)
```
